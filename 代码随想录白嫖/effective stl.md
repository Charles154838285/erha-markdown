## effective stl

### 熟悉stl本身

- 慎重选择stl容器，每一种stl容器对应不同的使用场景，比如deque<bool>往往比vector<bool>更加合适
- 封装stl容器，积极的使用stl，可以高效的使用它
- 积极使用其对应迭代器使用的函数，比如做相加运算使用accumulate替代for循环，可以更加高效
- 调用对应的函数的时候，不使用过于复杂的名称，防止C++编译机制出现错误
- STL并非线程安全的。它不支持并发的写入。所以在写入之前记得上锁
- 区别相等与等价：相等指的是里里外外完全相同，等价指的是可能只是外表相同
- #include的文件总是可以反复编写，因为他的头部都带有ifdefine，完全不用担心
- 当查询的操作和删除的操作几乎不混在一起的时候，排序的vector会比关联容器更好
- 不去修改set/mutiset的吉安，修改他们可能会导致位置的行为
- string的实现的多种多样，所以对应的大小也不是一样的

### 熟悉stl函数

- 调用empty而不是size。因为empty始终是常数时间。而size有些时候则是on
- 对于常见非关联容器，remove/remove-if和erase都是常见的删除用法，他能保证删除元素的同时改变容器大小。list使用remove，关联容器直接使用erase
- 对于已知容器的大小，可以使用reserve减少string/vector类容器增长所需要的时间，减少不必要的分配
- 使用swap函数对vector和string快速的放空有奇效，而且速度很快
- 编写比较函数的时候，我们不仅要保证operator<和less<T>要具有相同的意思，还更要保证要在等值的情况下返回false，保证一个严格的弱序化
- 对于逐个字符的输入，可以使用istreambuf-iterator
- 确保使用函数的时候，目标区间足够大，否则会导致一些未知的函数
- 熟悉常见的排序函数，包括sort，patition等函数
- 容器的成员函数优先于同名算法
- 确保判别式是纯函数。考虑函数对象而不是函数作为stl算法的参数

### 熟悉STL容器内部的对象

- 确保容器中的对象能高效的拷贝且正确。完整区分开深拷贝和浅拷贝
- 对于容器中包括了纯指针，记得要在容器对象析构前挨个delete指针。或者使用share-ptr。当然还有remove-erase也是一样

