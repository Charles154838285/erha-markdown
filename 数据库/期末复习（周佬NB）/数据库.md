# 数据库基础篇

[TOC]


## 第一章 绪论

**重点：**
[四个概念](# 四个基本概念)            
[数据模型的三个层次](# 1.2数据模型)  
[概念模型E-R图表示](#C：概念模型的一种表示方法：实体-联系方法)
[三级模式、两级映像](#1.3.3 二级映像)

### 1.1数据库系统概述

#### ==四个基本概念==

**数据(Data)**：

>**概念**：是数据库中存储的基本对象，是描述事物的符号记录
>
>**种类**：文本、图形、图像、音频、视频、学生的档案记录、货物的运输情况等
>
>**特点**：数据与其语义是不可分的
>
>PS:语义和解释：
>
>| 数据 | 李明     | 男   | 199905   | 06     |
>| ---- | -------- | ---- | -------- | ------ |
>| 语义 | 学生姓名 | 性别 | 出生年月 | 院系号 |
>
>解释：李明同学，男，1999年5月生，于06系就读

**数据库(DB)**：

>**概念**：是==永久存储==在计算机内(外存)，==有组织==、==可共享==的大量数据的集合
>
>**特征：**
>
>- 数据按一定的数据模型组织、描述和储存
>- 可为各种用户**共享**
>- **冗余度**较小
>- **数据独立性**较高
>- 易扩展

**数据库管理系统(DBMS)**：

>**概念**：是位于用户与操作系统之间的一层数据管理软件。和操作系统一样是计算机的基础软件，数据库是一个仓库，但是对数据库的操作是依靠DBMS完成的
>
>**功能**：
>
>- **数据==定义==功能**
>
>  ```提供数据定义语言(DDL)```
> ``` 定义数据库中的数据对象```
>
>- **数据==组织、存储和管理==功能**
>
>  `分类组织、存储和管理各种数据`
>  `确定组织数据的文件结构和存取方式`
>  `实现数据之间的联系`
>  `提供多种存取方法提高存取效率`
>
>- **数据==操纵==功能**
>
>  提供**数据操纵语言(DML)**
>  实现对数据库的基本操作 (**增删改查**)
>  
>- **数据库的事物==管理==和运行管理**
>
>  `数据库在建立、运行和维护时由DBMS统一管理和控制`
>  `保证数据的安全性、完整性、多用户对数据的并发使用`
>  `发生故障后的系统恢复`
>
>- **数据库的==建立和维护==功能（实用程序）**
>
>  `数据库初始数据装载转换`
>  `数据库转储`
>  `介质故障恢复`
>  `数据库的重组织`
>  `性能监视分析等`
> `其他功能（如通信、数据转换、互访等）`

**数据库系统(DBS)**：

>**概念**：在计算后的系统构成
>
>**组成**
>
>- **数据库 Database**
>- **数据库管理系统（及其开发工具）Database Management System**
>- **应用系统(app)**
>- **数据库管理员 Database Administrator(DBA)**
>
>**特点：**
>1：**数据结构化**（数据库系统与文件系统的本质区别）
>
>​		整体结构化是数据库的主要特征之一
>​		所谓整体结构化就是指它不针对某一个应用，而是面向全组织。不仅数据内部结构化并且数据之间也具有连续
>​		数据的结构用**数据模型**描述，无需程序定义和解释；数据可以变长；数据的最小存取单位是数据项
>
>2：**数据的共享性高**，冗余度低，易扩充
>
>3：**数据独立性高**（由DBMS的<span style="background:rgba(5, 117, 197, 0.2)">二级映像功能</span>保证）
>
>物理独立性：用户的应用程序与存储在磁盘上的数据库中数据是独立的。当数据的物理存储改变，应用程序不改变
>逻辑独立性：指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，用户程序也可以不变
>
>即：==不会因为数据存储结构或数据逻辑结构的变化而影响到应用程序==
>
>PS：为保证独立性：二级映射
>
>4：**数据由DBMS统一管理和控制**
>
>数据的安全性（Security）保护：保护数据，以防止不合法的使用造成的数据的泄密和破坏。
>数据的完整性（Integrity）检查：将数据控制在有效的范围内，或保证数据之间满足一定的关系。
>并发（Concurrency）控制：对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。
>数据库恢复（Recovery）：将数据库从错误状态恢复到某一已知的正确状态。
<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126160704760.png" alt="image-20231126160704760" style="zoom:67%;" />

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126160737109.png" alt="image-20231126160737109" style="zoom:67%;" align = "left"/>





### 1.2数据模型

数据模型是现实世界的模拟，现有的数据库系统均是基于某种数据模型的，==数据模型是数据库系统的核心与基础==

**组成要素**·：<span style="background:rgba(140, 140, 140, 0.12)">数据结构，数据操作，数据的约束条件</span>

**两个层次**：
- <span style="background:rgba(140, 140, 140, 0.12)">概念模型</span>
- <span style="background:rgba(140, 140, 140, 0.12)">逻辑模型/物理逻辑</span>

为了把现实世界中的具体事物抽象、组织为某一数据库管理系统支持的数据模型，人们常常首先将**现实世界**抽象为**信息世界**，然后将信息世界转换为**机器世界**。也就是说，首先把现实世界中的**客观对象**抽象为某一种**信息结构**，这种信息结构并不依赖于具体的计算机系统，不是某一个数据库管理系统支持的数据模型，而是概念级的模型:然后再把概念模型转换为计算机上某一数据库管理系统支持的**数据模型**

```
简要总结：
现实世界-信息世界-机器世界
客观对象-信息结构（概念模型）-数据模型(逻辑模型、物理模型)

概念模型主要用于数据库的设计
逻辑模型主要用于数据库管理系统的实现
物理模型面向计算机，描述数据在系统内部的表示方式和存取方式
```

<img src="D:\My Files\笔记\笔记图片\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16-1694594966807-19.png" alt="在这里插入图片描述" style="zoom:50%;" align="left"/>

----

- 从现实世界到概念模型的转换是由**数据库设计人员完成的**
- 从概念模型到逻辑模型的转换可由**数据库设计人员完成**
- 从逻辑模型到物理模型的转换主要是由**数据库管理系统完成**



#### 1.2.1概念模型（信息模型）

##### A：定义

**概念模型**：是按用户的观点来对数据和信息建模，用于数据库设计

##### B：信息世界相关术语

> **实体**： 客观存在并可以相互区别的事物。
>
> - 实体可以是具体的人、事、物，也可以是抽象的概念或联系，比如职工、学生、学生的一次选课、教师与院系的工作关系
>
> **属性**： 实体所具有的某一特性。一个实体可以由若干属性刻画
>
> - 比如(201315121， 张山，男，199505， 计算机系，2013) 即表征了一个学生

 

> **码：** 唯一标识实体的属性
>
> - 比如人的身份证号
>
> **实体型：** 用实体名及其属性集合来抽象和刻画同类实体
>
> - 比如学生(学号，姓名，性别，出生年月，所在院系)就是一个实体型
>
> **实体集：** 同一类型实体的集合
>
> - 例如全体学生就是一个实体集



> **联系：** 在现实世界中，事物内部以及事物之间是有联系的，这些联系在信息世界中反映为实体(型)内部的联系和实体(型)之间的联系。**实体内部的联系通常是指组成实体的各属性之间的联系，实体之间的联系通常是指不同实体集之间的联系**
>
> 实体之间的联系有一一对一、-对多和多对多 等多种类型



> [联想：第二章关系相关定义，第六章数据依赖]()



##### C：概念模型的一种表示方法：实体-联系方法

联系[概念结构设计](###7.3 概念结构设计)

实体联系方法用E-R图来描述现实世界的概念模型，所刻画的某些也称为E-R模型

- **实体型**：用矩形表示，矩形框内写明实体名
- **属性**：用椭圆形表示，并用无向边将其与相应的实体连接起来
- **联系**：用菱形表示，并用无向边将其余相应的实体型连接起来，同时在无向边旁表明联系的类型

<span style="background:rgba(140, 140, 140, 0.12)">注：若一个联系具有属性，则这些属性也要用无向边与该联系相连</span>

<img src="D:\My Files\笔记\笔记图片\image-20230913172457548.png" alt="image-20230913172457548" style="zoom:57%;" align = "left"/>

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126161139184.png" alt="image-20231126161139184" style="zoom:50%;" align = "left"/>



#### 1.2.2数据模型（逻辑模型，物理模型）

**==数据模型通常由 数据结构，数据操作，数据的完整性约束条件组成==**
<img src="D:\My Files\笔记\笔记图片\eb96b0d0af2cdb5996b7a6bd8babbf0.jpg" alt="image-20230913172457548" style="zoom:67%;" />

**数据逻辑模型：** 是按计算机系统的观点对数据建模，主要用于数据库管理系统的实现。主要包括

- 层次模型

- 网状模型

- ==**关系模型**(第2章-----第6章)==

  **`关系模型要求关系必须是规范化的`**

- 面向对象数据模型
- 对象关系数据模型
- 半结构化数据模型

**数据物理模型：** 是对数据最底层的抽象，它描述数据在系统内部的表示方式和存取方法，或在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。数据库设计人员需要了解和选择物理模型，但用户不需要考虑物理细节

#### 对关系模型的简要介绍
详细见[#第二章 关系数据库（主要讲关系模型）](##第二章 关系数据库（主要讲关系模型）)

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126161822280.png" alt="image-20231126161822280" style="zoom:70%;" align = "left"/><img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126161847745.png" alt="image-20231126161847745" style="zoom:0%;" />

![[Pasted image 20231019210452.png]]

----
![[Pasted image 20231019210515.png]]
![[Pasted image 20231019210534.png]]
![[Pasted image 20231019210543.png]]
![[Pasted image 20231019210555.png]]
![[Pasted image 20231019210621.png]]
![[Pasted image 20231019210610.png]]



### 1.3数据库系统的结构

#### 1.3.1数据库系统模式的基本概念

##### （1）型和值

[数据模型](https://so.csdn.net/so/search?q=数据模型&spm=1001.2101.3001.7020)中有“型(type)”和“值(value)”的概念

- **型(type)：** 对某一类数据的结构和属性的说明
- **值(value)：** 是型的一个具体赋值

<img src="D:\My Files\笔记\笔记图片\f954ae0869fc41f3acb1feae0b93c62c.png" alt="在这里插入图片描述" style="zoom:80%;" align="left"/>



-----

##### （2）模式和实例

实际的数据库管理系统产品种类很多:

不同的数据模型，不同的数据库语言，建立在不同的操作系统之上，数据的存储结构也各不相同

相同的体系特征：即采用**三级模式结构**(早期微机上的小型数据库系统除外)并提供**两级映像功能**

**模式(schema)：** 是数据库逻辑结构和特征的描述

- 是==型==的描述

- 反应的是数据的结构及其联系
- 模式相对**稳定**

**实例(instance)：** 模式的一个具体==值==

- 反映数据库某一时刻的状态

- 同一个模式可以有很多实例
- 实例随数据中的数据的更新而**变动**

**==一个数据库只有一个模式==，可以把模式看成是唯一的数据库，实例就是数据库里面的多个表**

所以MYSQL中创建模式其实也就是在创建数据库
<img src="D:\My Files\笔记\笔记图片\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16-1694602600108-25.png" alt="在这里插入图片描述" style="zoom:67%;" />

#### 1.3.2数据库系统的三级模式结构

==内模式-模式-外模式==
<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126162242860.png" alt="image-20231126162242860" style="zoom:80%;" />

-----

##### （1）模式(schema)

**模式：** 是数据库中<span style="background:rgba(140, 140, 140, 0.12)">全体数据</span> 的逻辑结构和特征的描述，是所有用户的公共数据视图，综合了所有用户的需求，对应概念模式

- 它是数据库模式结构的中间层，既不涉及数据的物理存储细节和硬件环境，又与具体的应用程序、所使用的应用开发工具及高级语言无关

- **一个数据库只有一个模式**
- 数据库模式以某一种数据模型为基础，统一考虑所有用户需求，并将这些需求有机结合为一个逻辑整体
- DBMS提供模式DDL来严格定义模式
- **`设计数据库模式结构时首先确定数据库的逻辑模式`**

##### （2）外模式(external schema)

**外模式：** 是<span style="background:rgba(140, 140, 140, 0.12)">数据库用户</span>（包括程序员和最终用户）能够看见和使用的 **局部** 的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑描述

- 外模式通常是模式的一个**子集**，所以模式与外模式的关系为一对多

- 一个数据库可以有**多个**外模式，反映了不同用户的需求（比如爱奇艺的付费用户和普通用户）
- 同一个外模式也可以为某一用户的多个应用系统所使用，但一个应用程序只能使用一个外模式
- 外模式是保证数据库安全性的一个有力措施。每个用户只能看见和访问所对应的外模式中的数据，数据库中的其余数据是不可见的
- DBMS提供外模式DDL来严格定义外模式

##### （3）内模式(internal schema)

- **内模式：** 是数据物理结构和存储方式的描述，<span style="background:rgba(140, 140, 140, 0.12)">是数据在数据库内部的表示方式</span>

- 一个数据库只有一个内模式
- 记录的存储方式（顺序存储，按照B树结构存储，按hash方法存储）
- 索引的组织方式
- 数据是否压缩存储
- 数据是否加密
- 数据存储记录结构的规定

![image-20231126162318676](D:\My Files\笔记\数据库\数据库.assets\image-20231126162318676.png)




#### 1.3.3 二级映像

作用：保证了数据库系统中的数据能够具有较高的`逻辑独立性`和`物理独立性`
<font color="#548dd4">数据独立性——数据库系统的特征之一·</font>

##### （1）外模式/模式映像

同一个模式可以有任意多个外模式，对于每一个外模式，数据库系统都有一个外模式/模式映像，它定义了该外模式与模式之间的对应关系

当模式改变时( `例如增加新的关系、新的属性、改变属性的数据类型等`)，由数据库管理员对各个外模式/模式的映像作相应改变，可以**使外模式保持不变**。应用程序是依据数据的外模式编写的，从而应用程序不必修改，==**保证了数据与程序的逻辑独立性**==，简称数据的逻辑独立性

```
类似：函数的自变量（模式）改变，要想值域（外模式）不变，就要更改映射（外模式/模式映像）
```



##### （2）模式/内模式映像

数据库的模式/内模式映像是唯一的，当数据库的存储结构改变时( 例如选用了另一种存储结构)，由数据库管理员对模式/内模式映像作相应改变，可以**使模式保持不变**。从而应用程序不必改变，==**保证了数据与程序的物理独立性**==，简称数据的物理独立性



### 1.4 数据库系统的组成

- 数据库
- 数据库管理系统（及其开发工具）
- 应用系统
- 数据库管理员
- 用户





---
-----


## 第二章 关系数据库（主要讲关系模型）

<span style="background:#b1ffff">重点：</span>
几个“关系XXX”概念之间的联系  [#**几个概念的理解**]
关系（二维表）的“下属”定义     [#**关系内的一些定义**：]
关系模式的表示                          [#二：关系模式]
关系的完整性                             [#2.3关系完整性]
**关系代数**                                    [#2.4 关系代数]

<span style="background:rgba(5, 117, 197, 0.2)">关系数据库：采用关系模型这种逻辑模型的数据库</span>
==**关系模型的三要素：基本结构，基本操作 ，关系完整性**==

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126162536868.png" alt="image-20231126162536868" style="zoom:80%;" />

----



### 2.1关系数据结构及形式化定义

重要概念：

- [型，值](==**型(type)：**==)
- [关系模型，关系，关系模式，关系数据库，关系数据库模式]()
- [关系中的“码”](**关系内的一些定义**：)


##### 一：关系

前面说过，关系模型建立在严格的数学概念之上，只包含<span style="background:rgba(140, 140, 140, 0.12)">单一的数据结构——关系</span>，**在用户看来关系就是一张二维表**

注：从用户角度，关系模型中数据的<span style="background:rgba(140, 140, 140, 0.12)">逻辑结构</span>是一张<span style="background:rgba(140, 140, 140, 0.12)">二维表</span>。

###### ——（1）域

**域**：是一组具有相同数据类型的值的集合

- 如自然数、整数、实数

######     ——(2）笛卡尔积

- **笛卡尔积**：是一种域上面的集合运算，得到每个域中元素的<span style="background:rgba(92, 92, 92, 0.2)">所有可能的组合</span>，它可以<span style="background:rgba(140, 140, 140, 0.12)">表示为一张二维表</span>，在笛卡尔积中有

- **元组**：<font color="#548dd4">每一行</font>是一个元组，比如 (张清玫，计算机专业，李勇)、(张清玫，计算机专业，刘晨)等都是元组（或者一条记录） ;
- **分量**：每一行中<font color="#548dd4">每一个元素</font>都是一个分量，比如张清玫、计算机专业、李勇、刘晨等都是分量
- **基数**：若D<sub>i</sub>（i＝1，2，…，n）为有限集，其基数为m<sub>i</sub>（i＝1，2，…，n），则D1×D2×…×Dn的基数M为：<span style="background:#affad1">（排列数）</span>

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126162636309.png" alt="image-20231126162636309" style="zoom:33%;" />


<img src="D:\My Files\笔记\笔记图片\a3a7da4fb5dc4e75b939fa787edcb41b.png" alt="在这里插入图片描述" style="zoom:67%;" />

<img src="D:\My Files\笔记\笔记图片\1ded063825bb40b2bfd8fd114a2f4afb.png" alt="在这里插入图片描述" style="zoom:67%;" />

<img src="D:\My Files\笔记\笔记图片\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16-1694588868134-10.png" style="zoom:67%;" />

上面的笛卡尔积中很多元组**是没有意义的**（例如在实际情形中一个导师一般专注于一个研究方向）。所以该笛卡尔积**的一个子集才是有意义的，才可以表示导师和研究生的关系**，例如

<img src="D:\My Files\笔记\笔记图片\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16-1694588925695-13.png" alt="在这里插入图片描述" style="zoom:50%;" />



###### ——（3）关系的表示及相关定义

==**关系**（即我们需要的表）是笛卡尔积的子集==，表示为

**```R(D1,D2,...Dn)```**

- R——关系的名称
- n——关系的目或度
- D~i~——域

##### **关系内的一些定义**：


<img src="D:\My Files\笔记\笔记图片\7c384cf31bda4c1897cc81198d994f3f.png" alt="在这里插入图片描述" style="zoom:50%;" />

----

>**元组：** 表的每一行对应一个元组，关系中的每个元素是关系中的元组，通常<span style="background:rgba(140, 140, 140, 0.12)">用t表示</span>。
>
>**属性：** 表的每一列对应一个属性（每列一个名字）
>
>**候选码：**==若关系中的某一属性组（注意是组不是某单个属性，当然有时属性组也可能只有一个属性）能唯一地标识一个元组，而其子集不能，则该属性组称之为候选码==
>
>- 上面关系中，学号是无法区分的，因为学号虽然不重复，但一个学生可能会对应多个课程，这就导致学号无法<span style="background:rgba(92, 92, 92, 0.2)">唯一标识一个元组</span>。因此这里（学号，课程名）可以作为一个候选码
>- 需要注意的是候选码不一定只有一个，<span style="background:rgba(92, 92, 92, 0.2)">可能有多个</span>，只要满足条件即可，但在本例中确实只有一个
>
>- **主属性和非主属性：** 包含在**候选码中的属性**（注意是集合，不是某个候选码）称为主属性；不包含在候选码中的属性称为非主属性
>
> <span style="background:rgba(5, 117, 197, 0.2)">关系的完整性约束中有对主属性的约束</span>
>- 上面关系中，姓名、性别和期末分数都是非主属性
>
>
>**全码：** 这是一种特殊情况：关系的<span style="background:rgba(140, 140, 140, 0.12)">所有属性组</span>是这个关系模式的候选码
>
>**超码：** 能够唯一标识一条记录的属性或属性集，**超码是候选码的扩充**，候选码是最小的超码
>
>- 上面关系中，（学号、课程名）是候选码，那么它的超集，例如（学号、课程名、姓名）、（学号、课程名、性别）就是超码
>
>**主码：** 某个能够唯一标识一条记录的**<span style="background:#affad1">最小属性集</span>**（候选码中的“人选之子”）**
>
>- 候选码可能有多个，但是数据库设计者在设计时会根据实际需求<font color="#548dd4">选择一个</font>候选码作为主码
>
>**外码：** <span style="background:rgba(140, 140, 140, 0.12)">是本关系的属性且不是码，而是另一个关系的主码</span>（后续会详细介绍）
>

<span style="background:#affad1">注意注意注意</span>
也许你注意到了，这些概念与[#1.2.1概念模型（信息模型）](###1.2.1概念模型（信息模型）)中的概念是相对应的。当时少了一部分没提：关系模型中的“联系”，即函数依赖，这一部分在[[#第六章 关系数据理论]] 将会详细地讲述

##### **关系的三种类型**

关系可以有三种类型

- **基本关系（又称为基本表）**：**实际存在**的表，是实际存储数据的逻辑表示
- **查询表**：**查询结果**对应的表
- **视图表**：由基本表或其他视图表导出的表，**是虚表**，不对应实际存储的数据

==注意==：关系模型要求关系必须是**规范化**的——最基本一条：关系的每一个分量都必须是一个不可分的数据项。



##### 二：关系模式

- ==**型(type)：**==对某一类数据的结构和属性的说明
- ==**值(value)：**==是型的一个具体赋值

在关系数据库中，==**关系模式就是型，关系就是值**==，**关系模式是对关系的描述**，具体来说要描述以下方面

- 元组集合的结构（由哪些属性构成、这些属性来自哪些域、属性与域之间的映像关系）
- 元组语义以及完整性约束
- 属性之间的数据依赖关系



一个关系模式应当是<span style="background:rgba(5, 117, 197, 0.2)">五元组</span>   **```R(U,D,DOM,F)```**

>- R：关系的元组语义
>- U：表示关系中的所有属性
>- D：表示属性组U中的属性所来自的域
>- DOM：属性到域的映射
>- **F：属性组U上的一组数据依赖**  [[#什么是数据依赖？]]



关系模式通常可以简记为（重点用）

```R (U)或R ( A1 ,A2,...,An ) ```

- R ：**关系名**
- A1 , A2 , . . . , An  ：**属性名**

- “域名”及“属性向域的映像”常常直接说明为属性的类型和长度

**关系与关系模型：**

```
关系模型建立在严格的数学概念之上，只包含单一的数据结构——关系
关系模型是安排好的总体架构，是静态的稳定的（基本结构，基本操作，完整性）
而关系是根据关系模型而定的 可变的某种结构类型，是关系模型的数据结构，是动态的，随时间不断变化的
```



##### 三：关系数据库

（1）基本概念
关系数据库：在一个给定的应用领域中，所有关系的集合构成的一个关系数据库

（2）关系数据库的型与值

**关系数据库的型**：也称为关系数据库模式，是对关系数据库的描述，包括

- 若干域的定义
- 在这些域上定义的若干关系模式

**关系数据库的值**：这些关系模式在某一时刻对应的关系的和，通常就叫做关系数据库

----

#### **几个概念的理解**
```
关系数据库系统 是支持关系模型的数据库系统
关系模型 由关系数据结构，关系操作集合，关系完整性约束组成
关系模型 的数据结构：关系(逻辑结构是二维表)
关系 是笛卡尔积的有限子集（一张二维表）
关系模式 是对关系的描述
关系数据库中 关系模式是型，关系是值
关系模式 五元组
关系数据库模式 是对关系数据库的描述，是关系数据库的型
```

<img src="D:\My Files\笔记\笔记图片\a03e86a11aab86a408233b14c2a78a5.jpg" style="zoom:50%;" />

----

### 2.2关系操作

<span style="background:rgba(92, 92, 92, 0.2)">注意：关系中的元素是记录，即一行</span>

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126163219436.png" alt="image-20231126163219436" style="zoom:50%;" align = "left"/>

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126163240753.png" alt="image-20231126163240753" style="zoom:50%;" align = "left"/>

**常用的关系数据语言**

<img src="D:\My Files\笔记\数据库\数据库.assets\ac30a6fd7508d75310e939ddf1f1ad0.jpg" alt="ac30a6fd7508d75310e939ddf1f1ad0" style="zoom:67%;" />

关系代数：用对关系的运算来表达查询要求

关系演算：用谓词来表达查询要求




### 2.3关系完整性

**关系完整性规则**是对关系的**某种约束条件**，这些约束条件实际上是现实世界的要求，例如性别只能有男、女两种取值（没有武装直升机）

关系模型中有如下三类完整性约束

- **实体完整性**（entity integrity）——`对候选码的约束`
- **参照完整性**（referential integrity）——`对外码的约束`
- **用户自定义完整性**（user-defined integrity）

其中实体完整性和参照完整性是关系模型必须满足的完整性约束，被称为<span style="background:rgba(92, 92, 92, 0.2)">关系的两个不变性</span>



#### 2.3.1 实体完整性

主属性：<font color="#548dd4">候选码</font>中的各个属性称为主属性
实体完整性： **主属性不能取空值**

- 解释：若主属性取空值，则说明存在某个不可标识的实体（矛盾）

```
例：
现有关系R：学生(学号，姓名，性别)
‘学号’属性为主码,则其不能取空值
```


#### 2.3.2 参照完整性

外码取**空值**，或者必须与相对应的关系（被参照关系）中的属性取**相同值**
<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126163354838.png" alt="image-20231126163354838" style="zoom:50%;" />

```
例
学生实体、专业实体以及专业与学生间的一对多联系
学生（学号，姓名，性别，专业号，年龄）  主码：学号
专业（专业号，专业名）                主码：专业号
‘专业号’称为学生关系的外码
```

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126163416708.png" alt="image-20231126163416708" style="zoom:50%;" align = "left"/>



#### 2.3.3 用户自定义完整性

- 用户定义的完整性是针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求。

- 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不要由应用程序承担这一功能。

举例：学生姓名这一属性要求非空；仓库零件数要求不小于0.

-----

### <span style="background:#ff4d4f">2.4 关系代数（待完成）</span>

**关系代数运算的分类**

1. **传统的集合运算(以 元组/行 为操作单元 )**

- 并、差、交、广义笛卡尔积

2. **专门的关系运算**

- 选择、投影、连接、除

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126165310910.png" alt="image-20231126165310910" style="zoom:40%;" align = "left"/><img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126165323428.png" alt="image-20231126165323428" style="zoom:40%;" />



#### 2.4.1 传统的集合运算

==并、差、交、广义笛卡尔积==——均为二目运算

前提：**关系R和关系S具有相同的目（都有n个属性），且相同的属性曲子同一个域**

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126165939664.png" alt="image-20231126165939664" style="zoom:30%;" align = "left"/>

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126170020960.png" alt="image-20231126170020960" style="zoom:33%;" align = "left"/>

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126170135016.png" alt="image-20231126170135016" style="zoom:33%;" align = "left"/>



#### 2.4.2 关系代数

==选择、投影、连接、除==

##### 1.选择

- 从<span style="background:rgba(92, 92, 92, 0.2)">行角度</span>进行计算
- 理解：筛选出表中满足某某条件的记录

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126170258397.png" alt="image-20231126170258397" style="zoom:33%;" />

**格式：**

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126170700737.png" alt="image-20231126170700737" style="zoom:80%;" />

例：有职工表Ｓ，试找出满足条件性别＝“女”的元组集：

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126170447285.png" alt="image-20231126170447285" style="zoom:67%;" />



##### 2.投影

- 从<span style="background:rgba(92, 92, 92, 0.2)">列角度</span>进行运算（即投影出想要的“信息”/属性）
- 投影之后不仅取消了原关系中的某些列，而且**还可能取消某些元组**（避免重复行）

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126170753984.png" alt="image-20231126170753984" style="zoom: 50%;" />

**格式**：

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126170833298.png" alt="image-20231126170833298" style="zoom:80%;" />

例：查询学生的姓名和所在系

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126170938998.png" alt="image-20231126170938998" style="zoom:67%;" align = "left"/>





##### 3.连接
- 一般的连接操作是从行的角度进行运算
- 从两个关系的笛卡尔积(R × S)中选取属性间<span style="background:rgba(92, 92, 92, 0.2)">满足一定条件</span>的元组

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126171045009.png" alt="image-20231126171045009" style="zoom:50%;" align="left"/>



两类常用连接运算：等值连接，自然连接

- **自然连接还需要取消重复列**，所以是同时从行和列的角度进行运算。

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126171157281.png" alt="image-20231126171157281" style="zoom:50%;" align = "left"/>

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126171212910.png" alt="image-20231126171212910" style="zoom:50%;" align = "left"/>

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126171224079.png" alt="image-20231126171224079" style="zoom:50%;" align = "left"/>

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126171236635.png" alt="image-20231126171236635" style="zoom:50%;" align = "left"/>



##### 4.除
- 除操作是同时从行和列角度进行运算

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126171525115.png" alt="image-20231126171525115" style="zoom:40%;" align = "left"/>

简单来说：（R÷S）的属性组是什么，留下的元组满足什么条件

- （**R÷S）的属性组X**：包含于R的属性组，且不为S中的属性（R中的属性“减去”S中的属性后的“属性组 差”）
- 找X各个元素在R中的象集
- 元组满足："在R中，可以找到该元组 **一对多**（S中**所有**Y上投影的元组集合）"

<img src="D:\My Files\笔记\数据库\数据库.assets\902dcf1a3e996c80315b3f59ed246a7.jpg" alt="902dcf1a3e996c80315b3f59ed246a7" style="zoom:40%;" align = "left"/>

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126173053973.png" alt="image-20231126173053973" style="zoom:33%;" align="left"/>






-----

### 2.5 关系演算（略）



-----
-----

## 第三章 结构化查询语言SQL

==笔记看看就行，这张记的很乱，不如看之前的PDF，半小时就能学会==

重点：(其实都是重点 -<sub>^</sub>-)
**select语句**        [[#4. **查找数据**]]



SQL的特点：

- 综合统一（DDL,DSDL,DML）
- 高度非过程化（==只提出做什么，无需指明怎么做、存取路径==）
- 面向集合的操作方式（操作对象是一条记录）
- 以同一种语法结构提供多种使用方式
- 语言简洁，易学易用

![[e6e1e3af4a32acf8ed029257b912033.jpg]]

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126173439602.png" alt="image-20231126173439602" style="zoom:70%;" align = "left"/>

中括号\[ ]仅仅表示内部是一个整体（可套用），输入时不用加


### 数据定义

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231024181217992.png" alt="image-20231024181217992" style="zoom:67%;" />

#### **建立数据库**

1. **建立数据库**

```mysql
CREATE DATABASE [if not exists] 数据库名 
	[character set 字符集 //指定字符集]
	[COllATE 校对规则 //指定校对规则];
```

```
常用的两种校对规则：

utf8_bin[区分大小写]
utf8_general_ci[不区分大小写]
```

2. **删除数据库**
```mysql
DROP DATABASE [IF EXISTS] 数据库名；
```

3. **查看所有的数据库**
```mysql
SHOW DATABASES;
```
4. **查看数据库创建语句**
```mysql
SHOW CREATE DATABASE [数据库名];
```

5. **备份/恢复数据库**
<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231126173543643.png" alt="image-20231126173543643" style="zoom:67%;" />

#### 定义模式

```mysql
CREATE SCHEME 模式名 AUTHORIZATION 用户名
-- 若没有指定模式名，则默认同用户名
-- 可进一步创建基本表，视图（紧接着create table等语句）
```

```mysql
-- 为用户wang定义一个学生-课程表模式S-T
CREATE SCHEME S-T AUTHORIZATION wang;
```

#### 删除模式

```mysql
DROP SCHEME 模式名 CASCADE/RESTRICT;
-- CASCADE(级联，删除模式下的所有对象)和RESTRICT(限制)必须二选一
```



#### **建立表**

1. **使用数据库/转到该数据库下操作**
```mysql
USE DATABASE 数据库名；
```

2. **建立表**
```mysql
CREATE TABLE [tablename]
(
	[列名1 列类型] [列级完整性约束条件(可不加) 如：不能为空> ]，
	[列名2 列类型] [列级完整性约束条件 ]，
	......
	[列名n 列类型] [列级完整性约束条件]
	[表级完整性约束条件]
)
[CHARACTER SET 字符集 //指定字符集]
[COLLATE 校对规则 //指定校对规则]
[ENGINE 引擎 //设置引擎](不加即默认);
```


#### **修改表-基本介绍**

1. **添加列**
```mysql
ALTER TABLE tablename
ADD [列名 列类型] [约束：如NOT NULL default ''(可不加)],
	...;
```
not null default '...' 表示：该字段不能为空，若没有指定，则填入默认值（default后面的）

2. **修改列**
```mysql
ALTER TABLE tablename
MODIFY [列名 新列名 列类型] [not..default],....;
```

3. **删除列**
```mysql
ALTER TABLE tablename
DROP 列名;
```

4. **修改表名**
```MYSQL
RENAME table 表名 to 表名;
```

5. **修改表字符集**
```mysql
ALTER TABLE tablename
character set 字符集;
```

6. **查看表信息**
```mysql
DESC 表名;
```

```mysql
#修改表的操作练习
--  员工表emp的上增加一个image列，varchar类型(要求在resume后面)。
ALTER TABLE emp 
	ADD image VARCHAR(32) NOT NULL DEFAULT '' 
	AFTER RESUME
DESC employee -- 显示表结构，可以查看表的所有列
--  修改job列，使其长度为60。
ALTER TABLE emp 
	MODIFY job VARCHAR(60) NOT NULL DEFAULT ''
--  删除sex列。
ALTER TABLE emp
	DROP sex
--  表名改为employee。
RENAME TABLE emp TO employee
--  修改表的字符集为utf8 
ALTER TABLE employee CHARACTER SET utf8
--  列名name修改为user_name
ALTER TABLE employee 
	CHANGE `name` `user_name` VARCHAR(64) NOT NULL DEFAULT ''
DESC employee
```

#### 建立索引

```mysql
CREATE [UNIQUE][CLUSTER] INDEX 索引名
ON 表名(列名 次序，列名 次序.....)

-- 次序：升序（ASC）降序（DESC）
-- UNIQUE:唯一索引（一个索引值只对应一个记录）
-- cluster:聚簇索引
```

```mysql
-- SC表按照学号升序和课程表降序建立唯一索引
CREATE UNIQUE INDEX SCno
ON SC(Sno ASC,Cno DESC);
```

#### 删除索引

```mysql
DROP INDEX 索引名
```



-----

### ==**记录的增删改查【CRUD】**==

#### 1. **添加数据**

```mysql
# 指定字段：
INSERT INTO 表名 (字段名1, 字段名2, ...) 
			VALUES (值1, 值2, ...);
```

```mysql		
# 全部字段：
INSERT INTO 表名 
	VALUES (值1, 值2, ...);
```

```mysql
# 批量添加数据：
INSERT INTO 表名 (字段名1, 字段名2, ...) 
			VALUES (值1, 值2, ...), 
			(值1, 值2, ...), 
			(值1, 值2, ...);
			
INSERT INTO 表名 
		VALUES (值1, 值2, ...), 
		(值1, 值2, ...), 
		(值1, 值2, ...);
```

 **注意事项**
- 字符串和日期类型数据应该包含在<font color="#548dd4">引号</font>中
- 插入的数据大小应该在字段的<font color="#548dd4">规定范围</font>内(<span style="background:rgba(140, 140, 140, 0.12)">即应该与对应的字符类型相匹配</span>)


#### 2. **修改数据**
```mysql
UPDATE 表名
	SET [列名 = value1],[可以是公式，如：salary = years * 100]...
	[where 条件] 
```

#### 3. **删除语句**
```mysql
DELETE FROM 表名
	[where 条件]
```

<span style="background:rgba(140, 140, 140, 0.12)">注：delete不能删除某一列的值（可以用update设为null或‘’）</span>

#### 4. **查找数据**

**语法：**
```mysql
SELECT
	字段列表
FROM
	表名字段
WHERE
	条件列表
GROUP BY
	分组字段列表
HAVING
	分组后的条件列表
ORDER BY
	排序字段列表
LIMIT
	分页参数
```

注意：==查找数据==并不仅限于 表中有的项或是结构，字段列表也可以是公式、函数
##### **基础查询**

**查询多个字段：**
```mysql
SELECT 字段1, 字段2, 字段3, ... FROM 表名;
SELECT * FROM 表名; //显示所有字段
```


<span style="background:rgba(240, 107, 5, 0.2)">设置别名：</span>
```mysql
SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], ... 
		FROM 表名;
SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;
```

<span style="background:rgba(92, 92, 92, 0.2)">注意：别名不会改变实际的属性名；别名最好不要用纯数字</span>
**例子：**
```mysql
-- 统计每个学生的总分
SELECT Sname as 姓名, (chinese + english + math) as 总分 
		from score
```

**去除重复记录：**
`SELECT DISTINCT 字段列表 FROM 表名;`
注意：select出的字段列表  对应的记录 要**完全相同**才可以去重

**转义：**
转义字符：\`，\\
`SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/'`
/ 之后的\_不作为通配符



##### **条件查询**

语法：
`SELECT 字段列表 FROM 表名 WHERE 条件列表;`

where xx属性（组）符合xx条件
###### where子句中常用的运算符：

| 比较运算符          | 功能                                                                                                                                   |
| ------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| >                   | 大于                                                                                                                                   |
| >=                  | 大于等于                                                                                                                               |
| <                   | 小于                                                                                                                                   |
| <=                  | 小于等于                                                                                                                               |
| =                   | 等于                                                                                                                                   |
| <> 或 !=            | 不等于                                                                                                                                 |
| BETWEEN ... AND ... | 在某个范围内（含最小、最大值，即闭区间）                                                                                                         |
| IN(...)             | 在in之后的列表中的值，<span style="background:#d3f8b6">多选一 </span>                                                                                                          |
| LIKE 占位符         | 匹配模板：固定字符串或含通配符的字符串，模糊匹配<span style="background:#d3f8b6">（ _ 匹配单个字符，% 匹配任意个字符）</span> |
| IS NULL             | 是NULL                                                                                                                                 |

| 逻辑运算符         | 功能                         |   备注  |
| ------------------ | ---------------------------- | --- |
| AND 或 &&          | 并且（多个条件同时成立）     |优先级次高     |
| OR 或 &#124;&#124; | 或者（多个条件任意一个成立） |优先级最低     |
| NOT 或 !           | 非，不是                     |优先级最高     |

**例子：**
```mysql
-- 年龄等于30
select * from employee where age = 30;
-- 年龄小于30
select * from employee where age < 30;
-- 小于等于
select * from employee where age <= 30;

-- 没有身份证
select * from employee where idcard is null or idcard = '';

-- 有身份证
select * from employee where idcard;
select * from employee where idcard is not null;

-- 不等于
select * from employee where age != 30;

-- 年龄在20到30之间
select * from employee where age between 20 and 30;
select * from employee where age >= 20 and age <= 30;

-- 下面语句不报错，但查不到任何信息
select * from employee where age between 30 and 20;

-- 性别为女且年龄小于30
select * from employee where age < 30 and gender = '女';

-- 年龄等于25或30或35
select * from employee where age = 25 or age = 30 or age = 35;
select * from employee where age in (25, 30, 35);

-- 姓名为两个字
select * from employee where name like '__';
********
-- 身份证最后为X
select * from employee where idcard like '%X';
```

```mysql
-- 查询语文分数在70-80之间的同学
select * from student
		where chinese between 70 and 80;

-- 查询总分在189,190,191的同学
select * from student
		where (chinese + math + english) in (189,190,191);

-- 查询所有姓李 或者姓宋的学生成绩
select * from student
		where `name` = "李%" or `name` = "宋%";
```
##### **聚合查询（聚合函数）**

常见聚合函数：

| 函数  | 功能                         |
| ----- | ---------------------------- |
| count | 统计数量（**返回行的总数**） |
| max   | 最大值                       |
| min   | 最小值                       |
| avg   | 平均值                       |
| sum   | 求和                         |

语法：
`SELECT 聚合函数(字段列表) FROM 表名;`

###### **1. count**

返回行的总数

count(*) 和 count(列) 的**区别**：*

- 解释 : `count(*)` 返回满足条件的记录的行数
- `count(列)`: 统计满足条件的某列有多少个，但是会排除 ` 该列为null `的情况

```mysql
CREATE TABLE t15 (
`name` VARCHAR(20));
INSERT INTO t15 VALUES('tom');
INSERT INTO t15 VALUES('jack');
INSERT INTO t15 VALUES('mary');
INSERT INTO t15 VALUES(NULL);
SELECT * FROM t15;
SELECT COUNT(*) FROM t15; -- 返回4
SELECT COUNT(`name`) FROM t15;-- 返回3（排除了为空的情况）
```

###### 2. sum

返回满足where条件的 记录中对应列的和（一般使用在==数值列==）
```mysql
-- 演示 sum 函数的使用

-- 统计一个班级数学总成绩？
SELECT SUM(math) FROM student;
-- 统计一个班级语文、英语、数学各科的总成绩
SELECT SUM(math) AS math_total_score,SUM(english),SUM(chinese) FROM student; 
-- 统计一个班级语文、英语、数学的成绩总和
SELECT SUM(math + english + chinese) FROM student; 
-- 统计一个班级语文成绩平均分
SELECT SUM(chinese)/ COUNT(*) FROM student;
-- 无意义，但不会报错
SELECT SUM(`name`) FROM student;
```

###### 3. avg

返回满足where条件的一列的平均值

```mysql
-- 演示 avg 的使用

-- 求一个班级数学平均分？
SELECT AVG(math) FROM student;
-- 求一个班级总分平均分
SELECT AVG(math + english + chinese) FROM student;
```

###### 4.min、max

返回满足where条件的一列中的最大值

```mysql
-- 演示 max 和 min 的使用

-- 求班级最高分和最低分（数值范围在统计中特别有用）
SELECT MAX(math + english + chinese), MIN(math + english + chinese) from student;
```



例：

````mysql
-- 统计在广东省工作的职工数
 SELECT count(id) from employee where workaddress = "广东省";
-- 统计一个班级语文、英语、数学各科的总成绩
SELECT SUM(math) AS math_total_score,SUM(english),SUM(chinese) FROM student;
-- 统计一个班级语文成绩平均分
SELECT SUM(chinese)/ COUNT(*) FROM student;
-- 求班级最高分和最低分（数值范围在统计中特别有用）
SELECT MAX(math + english + chinese), MIN(math + english + chinese) FROM student; 
-- 求一个班级总分平均分
SELECT AVG(math + english + chinese) FROM student
````

----



##### **分组查询**(group by ... having ...)

`group by子句`: 对列进行分组

`having子句`: 对分组后的结果进行过滤



**语法：**

```
SELECT 字段列表 FROM 表名 
			   [ WHERE 条件 ] 
			   GROUP BY 分组字段名 
			   [ HAVING 分组后的过滤条件 ];
```

where 和 having 的区别：

- 执行时机不同：<span style="background:rgba(92, 92, 92, 0.2)">where是分组之前进行过滤</span>，不满足where条件不参与分组；**having是对分组后的结果进行过滤**。
- 判断条件不同：<span style="background:rgba(92, 92, 92, 0.2)">where不能对聚合函数进行判断</span>，而having可以。

**例子对应的表：**D:\My Files\A-main_course\A-数据库\学mysql要创建的表\雇员系统表.txt

类似：显示......的xxx——就是按照XXX分组

```mysql
# 演示 group by + having
GROUP by 用于对查询的结果分组统计, (示意图)
-- having 子句用于限制分组显示结果. 

-- ?如何显示每个部门的平均工资和最高工资
-- 老韩分析: avg(sal) max(sal)
-- 按照部分来分组查询
SELECT AVG(sal), MAX(sal) , deptno
FROM emp GROUP BY deptno;
-- 使用数学方法，对小数点进行处理
SELECT FORMAT(AVG(sal),2), MAX(sal) , deptno
FROM emp GROUP BY deptno; 

-- ?显示每个部门的每种岗位的平均工资和最低工资
-- 老师分析
-- 1. 显示每个部门的平均工资和最低工资
-- 2. 显示每个部门的每种岗位的平均工资和最低工资

SELECT AVG(sal), MIN(sal) , deptno, job
FROM emp GROUP BY deptno, job; 


-- ?显示平均工资低于 2000 的部门号和它的平均工资 // 别名

-- 老师分析 [写 sql 语句的思路是化繁为简,各个击破]
-- 1. 显示各个部门的平均工资和部门号
-- 2. 在 1 的结果基础上，进行过滤，保留 AVG(sal) < 2000
-- 3. 使用别名进行过滤

SELECT AVG(sal), deptno
FROM emp GROUP BY deptno
HAVING AVG(sal) < 2000; -- 使用别名

SELECT AVG(sal) AS avg_sal, deptno
FROM emp GROUP BY deptno
HAVING avg_sal < 2000;

```

**注意事项**
- 执行顺序：where > 聚合函数 > having
- ==分组之后，查询的字段一般为聚合函数和分组字段==，查询其他字段无任何意义
- PS：相当于增添了一个分组相关的字段

**DQL执行顺序**

==FROM -> WHERE -> GROUP BY -> SELECT -> ORDER BY -> LIMIT==

###### 加强

```mysql
-- 增强 group by 的使用

-- (1) 显示每种岗位的雇员总数、平均工资。
SELECT COUNT(*), AVG(sal), job
FROM emp
GROUP BY job; 

-- (2) 显示雇员总数，以及获得补助的雇员数。
-- 思路: 获得补助的雇;;员数 就是 comm 列为非 null, 就是 count(列)，如果该列的值为 null, 是
-- 不会统计 , SQL 非常灵活，需要我们动脑筋.
SELECT COUNT(*), COUNT(comm)
FROM emp
-- 老师的扩展要求：统计没有获得补助的雇员数
SELECT COUNT(*), COUNT(IF(comm IS NULL, 1, NULL))
FROM emp
SELECT COUNT(*), COUNT(*) - COUNT(comm)
FROM emp

-- (3) 显示管理者的总人数。
-- 小技巧:尝试写->修改->尝试[正确的]
SELECT COUNT(DISTINCT mgr)
FROM emp; 

-- (4) 显示雇员工资的最大差额。
-- 思路： max(sal) - min(sal)
SELECT MAX(sal) - MIN(sal)
FROM emp;
SELECT * FROM e
mp;
select * from dept;


-- 应用案例：请统计各个部门 group by 的平均工资 avg，
-- 并且是大于 1000 的 having，并且按照平均工资从高到低排序， order by
-- 取出前两行记录 limit 0, 2
SELECT deptno, AVG(sal) AS avg_sal
FROM emp
GROUP BY deptno
HAVING avg_sal > 1000
ORDER BY avg_sal DESC
LIMIT 0,2
```



----


##### 排序查询（ORDER BY）

**语法：**

```
SELECT 字段列表 
FROM 表名 
ORDER BY 字段1 排序方式1, 
		 字段2 排序方式2;
```



**排序方式**：

- **ASC: 升序（默认）**
- **DESC: 降序**

例子：
```mysql
-- 根据年龄升序排序
SELECT * FROM employee ORDER BY age ASC;
SELECT * FROM employee ORDER BY age;
-- 两字段排序，根据年龄升序排序，入职时间降序排序
SELECT * FROM employee ORDER BY age ASC, entrydate DESC;
-- 对总分按从高到低的顺序输出 [降序] -- 使用别名排序
SELECT `name` , (chinese + english + math) AS total_score 
FROM student
ORDER BY total_score DESC;
```

**注意事项**

![image-20231024180821432](D:\My Files\笔记\数据库\数据库.assets\image-20231024180821432.png)如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序
当排序列含空值时：

- ASC：排序列为空值的元组最后显示
- DESC：排序列为空值的元组最先显示

----

##### 单表查询（加强）

1. 使用where语句

`在 mysql 中,日期类型可以直接比较, 需要注意格式`

```mysql
-- ?如何查找 1992.1.1 后入职的员工
SELECT * FROM emp
WHERE hiredate > '1992-01-01
```



2. 如何使用like操作符（模糊查找）

` %: 表示 0 到多个任意字符    _: 表示单个任意字符`

```mysql
-- ?如何显示首字符为 S 的员工姓名和工资
SELECT ename, sal FROM emp
WHERE ename LIKE 'S%' 

-- ?如何显示第三个字符为大写 O 的所有员工的姓名和工资
SELECT ename, sal FROM emp
WHERE ename LIKE '__O%'
```



3. 如何显示没有xxx属性的记录

`判断某列是否为空：is null`

```mysql
-- 如何显示没有上级的雇员的情况
SELECT * FROM emp
WHERE mgr IS NULL;
```



4. 查询表结构

```mysql
DESC emp（即表名）
```



----



##### 连接查询（多表查询）



###### 隐式连接

在默认情况下，当两个表查询时：

1. 如果不加上任何的规则限制，则两张表做笛卡尔积（两表记录“组合”）
2. 如果where子句中有限制/过滤条件，则“组合”两表记录时，要遵循限制
3. ==小技巧：多表查询的条件/过滤条件不能少于 表的个数-1, 否则会出现笛卡尔集==

```mysql
-- 多表查询

-- ?显示雇员名,雇员工资及所在部门的名字 【笛卡尔集】

/*分析
1. 雇员名,雇员工资 来自 emp 表
2. 部门的名字 来自 dept 表
3. 需求对 emp 和 dept 查询 ename,sal,dname,deptno
4. 当我们需要指定显示某个表的列是，需要 表.列表
*/

SELECT ename,sal,dname,emp.deptno
FROM emp, dept
WHERE emp.deptno = dept.deptno

-- ?如何显示部门号为 10 的部门名、员工名和工资
SELECT ename,sal,dname,emp.deptno
FROM emp, dept
WHERE emp.deptno = dept.deptno AND emp.deptno = 10

-- ?显示各个员工的姓名，工资，及其工资的级别
-- 思路 姓名，工资 来自 emp 13
-- 工资级别 salgrade 5
-- 写 sql , 先写一个简单，然后加入过滤条件... select ename, sal, grade
from emp , salgrade
where sal between losal and hisal;

```



###### 自连接

在同一张表上的连接查询（将同一张表看做两张表——起别名）

```mysql
-- 多表查询的 自连接

-- 思考题: 显示公司员工名字和他的上级的名字
-- 老韩分析： 员工名字 在 emp, 上级的名字的名字 emp
-- 员工和上级是通过 emp 表的 mgr 列关联

-- 这里老师小结：
-- 自连接的特点 
-- 1. 把同一张表当做两张表使用
-- 2. 需要给表取别名 表名 表别名
-- 3. 列名不明确，可以指定列的别名 列名 as 列的别名

SELECT worker.ename AS '职员名' , boss.ename AS '上级名' 
		FROM emp worker, emp boss
		WHERE worker.mgr = boss.empno;
SELECT * FROM emp
```



###### ==显式连接（包括左右连接）==

```mysql
select []
from A join B on A.x = B.x;
-- 等价于：
select []
from A,B
WHERE A.x=B.x;
```

某些情况下，隐式链接（where =）会丢失信息：如查询学生选课数量时，当Student表与SC表隐式连接（`from student,sc where student.sno = sc.sno`）时，会丢失student表中未选修课程的学生的信息，此时需要使用左/右连接：

```mysql
-- 顾名思义，左连接保留左边的信息，右连接保存右边的
-- 注意，在额外筛选语句如select,group by 中，用保留信息的表，不然白写left和right了
A left join B on [连接条件]
A right join B on [连接条件]
```





##### ==嵌套查询（子查询）==

子查询指**嵌入在其他的mysql语句**中的 select语句

- 单行子查询：只返回一行数据的子查询语句
- 多行子查询：返回多行数据的子查询（用 `in`）
- 多列子查询

一般子查询结果是满足某某条件的记录的**码**

==即先select出码，在根据问题改子查询语句==

```mysql
-- 子查询的演示

-- 请思考：如何显示与 SMITH 同一部门的所有员工?
/*
1. 先查询到 SMITH 的部门号得到

2. 把上面的 select 语句当做一个子查询来使用

*/
SELECT deptno
FROM emp
WHERE ename = 'SMITH' -- 下面的答案. SELECT *
FROM emp
WHERE deptno = (
SELECT deptno
FROM emp
WHERE ename = 'SMITH' )

-- 课堂练习:如何查询和部门 10 的工作相同的雇员的
-- 名字、岗位、工资、部门号, 但是不含 10 号部门自己的雇员.
/*
1. 查询到 10 号部门有哪些工作
2. 把上面查询的结果当做子查询使用
*/
select distinct job
from emp
where deptno = 10; -- 下面语句完整

select ename, job, sal, deptno
from emp
where job in (
SELECT DISTINCT job
FROM emp
WHERE deptno = 10
) and deptno <> 10
```



###### 子查询当做临时表使用

==即将子查询结果放在from中，或者结合in/not in放在where、group by、having子句中==

```mysql
-- 请思考：查找每个部门工资高于本部门平均工资的人的资料
-- 这里要用到数据查询的小技巧，把一个子查询当作一个临时表使用

-- 1. 先得到每个部门的 部门号和 对应的平均工资
SELECT deptno, AVG(sal) AS avg_sal
FROM emp GROUP BY deptno

-- 2. 把上面的结果当做子查询, 和 emp 进行多表查询
--SELECT ename, sal, temp.avg_sal, emp.deptno
FROM emp, (
SELECT deptno, AVG(sal) AS avg_sal
FROM emp
GROUP BY deptno
) temp
WHERE emp.deptno = temp.deptno AND emp.sal > temp.avg_sal 

-- 查找每个部门工资最高的人的详细资料
SELECT ename, sal, temp.max_sal, emp.deptno
FROM emp, (
SELECT deptno, MAX(sal) AS max_sal
FROM emp
GROUP BY deptno
) temp
WHERE emp.deptno = temp.deptno AND emp.sal = temp.max_sal

-- 查询每个部门的信息(包括：部门名,编号,地址)和人员数量,我们一起完成。
-- 1. 部门名,编号,地址 来自 dept 表
-- 2. 各个部门的人员数量 -》 构建一个临时表

SELECT COUNT(*), deptno
FROM emp
GROUP BY deptno;


SELECT dname, dept.deptno, loc , tmp.per_num AS '人数' FROM dept, (
SELECT COUNT(*) AS per_num, deptno
FROM emp
GROUP BY deptno
) tmp
WHERE tmp.deptno = dept.deptno

-- 还有一种写法 表.* 表示将该表所有列都显示出来, 可以简化 sql 语句
-- 在多表查询中，当多个表的列不重复时，才可以直接写列名

SELECT tmp.* , dname, loc
FROM dept, (
SELECT COUNT(*) AS per_num, deptno
FROM emp
GROUP BY deptno
) tmp
WHERE tmp.deptno = dept.deptno
```



###### all any的使用

```mysql
-- 请思考:显示工资比部门 30 的所有员工的工资高的员工的姓名、工资和部门号
-- >all() 或者 > max()
SELECT ename, sal, deptno
FROM emp
WHERE sal > ALL(
SELECT sal
FROM emp
WHERE deptno = 30
)
-- 可以这样写

SELECT ename, sal, deptno
FROM emp
WHERE sal > (
SELECT MAX(sal)
FROM emp
WHERE deptno = 30
)

-- 请思考:如何显示工资比部门 30 的其中一个员工的工资高的员工的姓名、工资和部门号
SELECT ename, sal, deptno
FROM emp
WHERE sal > any(
SELECT sal
FROM emp
WHERE deptno = 30
)
SELECT ename, sal, deptno
FROM emp
WHERE sal > 
(SELECT min(sal) FROM emp WHERE deptno = 30
)
-- 查询 ecshop 中各个类别中，价格最高的商品

-- 查询 商品表

-- 先得到 各个类别中，价格最高的商品 max + group by cat_id, 当做临时表

-- 把子查询当做一张临时表可以解决很多很多复杂的查询

select cat_id , max(shop_price)
from ecs_goods
group by cat_id
-- 这个最后答案

select goods_id, ecs_goods.cat_id, goods_name, shop_price
from (
SELECT cat_id , MAX(shop_price) as max_price
FROM ecs_goods
GROUP BY cat_id
) temp , ecs_goods
where temp.cat_id = ecs_goods.cat_id
and temp.max_price = ecs_goods.shop_price
```

###### 多列子查询

查询返回多个列数据的子查询语句、

```mysql
-- 多列子查询

-- 请思考如何查询与 allen 的部门和岗位完全相同的所有雇员(并且不含 allen 本人)
-- (字段 1， 字段 2 ...) = (select 字段 1，字段 2 from 。。。。)

-- 分析: 1. 得到 smith 的部门和岗位
SELECT deptno , job
FROM emp
WHERE ename = 'ALLEN'

-- 分析: 2 把上面的查询当做子查询来使用，并且使用多列子查询的语法进行匹配
SELECT *
FROM emp
WHERE (deptno , job) = (
SELECT deptno , job
FROM emp
WHERE ename = 'ALLEN' ) AND ename != 'ALLEN'

-- 请查询 和宋江数学，英语，语文
-- 成绩 完全相同的学生
SELECT *
FROM student
WHERE (math, english, chinese) = (
SELECT math, english, chinese
FROM student
WHERE `name` = '宋江' )

SELECT * FROM student;
```



----

##### **分页查询**（limit）

**语法：**
`SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;`

==order by 和limit子句都在select的最后，limit最后==

![image-20231024193819966](D:\My Files\笔记\数据库\数据库.assets\image-20231024193819966.png)

例子：

```mysql
-- 查询第一页数据，展示10条
SELECT * FROM employee LIMIT 0, 10;
-- 查询第二页
SELECT * FROM employee LIMIT 10, 10;

-- 按雇员的 id 号升序取出， 每页显示 3 条记录，请分别显示 第 1 页，第 2 页，第 3 页
-- 第 1 页
SELECT * FROM emp
ORDER BY empno
LIMIT 0, 3; 
-- 第 2 页
SELECT * FROM emp
ORDER BY empno
LIMIT 3, 3; 
-- 第 3 页
SELECT * FROM emp
ORDER BY empno
LIMIT 6, 3;
```

**注意事项**

- 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数
- 分页查询是数据库的方言，**不同数据库有不同实现，**MySQL是LIMIT
- 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10

**DQL执行顺序**

==FROM -> WHERE -> GROUP BY -> SELECT -> ORDER BY -> LIMIT==

### 视图

![image-20231030085918672](D:\My Files\笔记\数据库\数据库.assets\image-20231030085918672.png)

##### 建立视图

```mysql
CREATE VIEW 视图名 (列名，列名....可省略不写)
AS 
< select子查询语句 >
```

建立视图时，可添加一句：`with check option`——保证对视图进行操作时，更新、插入、删除的行满足子查询中的条件表达式

##### 修改视图

注意：对视图进行更新操作时，要求视图不能有“聚合属性”

>DB2对视图更新的限制：
>
>(1) 若视图是由两个以上基本表导出的，则此视图不允许更新。
>
>(2) 若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。

视图是不实际存储数据的虚表，**对视图的更新最终要转换为对基本表的更新**



##### 查询视图

将视图当成表来用，可以在视图的基础上再建立视图

##### 视图的作用

- 视图能够简化用户的操作
- 视图使用户能以多种角度看待同一数据
- 视图对重构数据库提供了一定程度的逻辑独立性
- 视图能够对机密数据提供安全保护

### 定义约束（见第五章）

-----
-----

## <span style="background:#ff4d4f">第四章 数据库安全性（自学内容 课设）(待完成)</span>



数据安全性：保护数据库，防止恶意破坏和非法存储

-----
-----



## 第五章 数据库完整性（自学内容 课设）

**完整性** 都是在`CREATE TABLE` 层面上定义的
**断言**
**触发器** 是在`insert,update,delete`操作的层面上定义的



数据库完整性组成：**防止**数据库中存在**不符合语义**的数据

- 数据的正确性（符合当前语义和实际情况）
- 数据的相容性（数据库同一对象在不同关系表中的数据是符合逻辑的）



**数据库管理系统需要提供的功能：**

1. 提供定义完整性约束条件的机制
   - 使用sql的数据定义语言描述`实体完整性，参照完整性，用户定义完整性`，存入数据库模式的`数据字典`中
2. 提供完整性检查的方法
   - 执行更新、删除、插入操作后开始检查
3. 进行违约处理
   - 如拒绝（NO ACTION）执行该操作、级联（cascade）执行其他操作

### 5.1 实体完整性

[相关概念1](### 2.3.1 实体完整性)

#### 5.1.1 在关系模型中的定义方法：

在 `CREATE TABLE` 中用 `PRIMARY KEY`定义 

```mysql
-- 在列级定义主码
create table student
	(sno char(9) PRIMARY KEY,
     SNAME CHAR(9) NOT NULL,
     SAGE TINYINT
    );
```

```mysql
-- 在表级定义主码（可以定义属性组为主码）
create table sc
	(Sno char(9),
     Cno CHAR(9),
     grade tinyint，
     PRIMARY KEY(Sno,Cno)
    );
```



#### 5.1.2 实体完整性检查和违约处理

- 立即执行的约束(Immediate constraints)语句执行完后立即检查是否违背完整性约束
- 延迟执行的约束(Deferred constrainsts)完整性检查延迟到整个事务执行结束后进行

>每当插入或对主码列进行更新操作时，DBMS按照实体完整性规则自动进行检查，包括
>
>- 检查主码值是否唯一，如果不唯一则拒绝插入或修改
>-  检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改
>
> 
>
>其中**检查记录中主码值是否唯一**有两种方法
>
>- **全表扫描**：十分耗时
>
><img src="D:\My Files\笔记\数据库\数据库.assets\image-20231101104508632.png" alt="image-20231101104508632" style="zoom:33%;" align = "left"/>
>
>- **建立索引**：关系数据库管理系统一般都会在**主码**上自动建立一个**索引**
>
><img src="D:\My Files\笔记\数据库\数据库.assets\image-20231101104537997.png" alt="image-20231101104537997" style="zoom:33%;" align = "left"/>

**违约处理方式**

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231101104117139.png" alt="image-20231101104117139" style="zoom:80%;" />

----



### 5.2参照完整性

[相关概念2](# 2.3.2参照完整性)

#### 5.2.1 定义参照完整性

关系模型在 `CREATE TABLE` 中用 `FOREIGN KEY() REFERENCES `**定义外码**,并指明外码**参照**哪些表的主码
注意：同时也要定义**被参照表**中的相应**主码**

```mysql
create table sc
	(Sno char(9),
     Cno CHAR(9),
     grade tinyint,
     PRIMARY KEY(Sno,Cno),  //在表级定义实体完整性（主码）
     FOREIGN KEY(Sno) REFERENCES students(Sno),  //在表级定义参照完整性（外码）
     FOREIGN KEY(Cno) REFERENCES course(Cno) //在表级定义参照完整性（外码）
    );
```



#### 5.2.2 参照完整性检查和违约处理



##### 破坏完整性的行为

参照完整性将表与表联系在了一起，所以对其中一个表的修改很可能会影响到另外一张表

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231101105558124.png" alt="image-20231101105558124" style="zoom:50%;" align = "left"/>

><img src="D:\My Files\笔记\数据库\数据库.assets\image-20231101105716050.png" alt="image-20231101105716050" style="zoom:50%;" />
>
><img src="D:\My Files\笔记\数据库\数据库.assets\image-20231101105730278.png" alt="image-20231101105730278" style="zoom:50%;" />
>
>即：**参照表**（外码）可以执行**删除元组**操作；**被参照表**（主码）可以执行**插入元组**操作



##### **违约处理策略：**

**1.拒绝**
即不允许该操作执行，一般设置为==默认的违约处理策略==

**2.级联（CASCADE）**
级联：当删除或修改Student表（被参照表）的一个元组导致与sc表（参照表）**不一致**时，则**会删除或修改**sc表（参照表）中的所有**导致不一致**的元组

```
比如删除Student表中Sno为“201215121”的元组后，则会从sc表中级联删除sc.Sno='201215121'的所有元组
注意：在这个例子中，按照语义环境选择级联删除是正确的，因为学生信息一旦删除了，那么成绩信息就没有存在的意义了
```

**3.设为空值（update set null）**

原理：外码与被参照表的主码保持一致，或者**为空**

> 假设有下面两个关系（划线为主码）：参照表为学生表，被参照表为专业表
> 设为空值：当删除或修改专业表（被参照表）的一个元组时造成了不一致，则将学生表（参照表）中的所有造成不一致的元组的对应属性（专业号）设为空值

比如删除专业表中专业号为12的专业，那么接着就要把学生表中专业号=12的所有元组的专业号**设置为空值**
注意：在这个例子中，按照语义环境选择设置为空值是正确的，因为专业一旦删除，表明该学生需要重新分配专业，除非该学生毕业，否则不可能把学生信息给删除



**SQL语句**：在定义表级的参照完整性后加上 ： `on < delete/update/insert > < 违规处理策略 >` ，表示对该表进行某某操作时，执行违规处理策略

举例：

```mysql
CREATE TABLE SC
(
	Sno CHAR(9)
	Sno CHAR(4) 
	Grade SMALLINT,								//是外码也是主码，故不能取空值，实体完整性
	PRIMARY KEY(Sno,Cno),
	FOREIGN KEY(Sno) REFERENCES Student(Sno)
		ON DELETE CASCADE 						//删除Student表的元组时，级联删除本表相应元组
		ON UPDATE CASCADE, 						//更新Student表中的Sno时，级联更新本表相应元组
	FOREIGN KEY(Cno) REFERENCES Course(Cno)
		ON DELETE NO ACTION 					//删除Course表的元组造成不一致时，拒绝执行
		ON UPDATE CASCADE 						//更新Course表中的Cno时，级联更新本表相应元组
);

```



----



### 5.3 用户定义的完整性

[相关概念3](# 2.3.3用户定义的完整性)

用户自定义完整性针对某一具体关系数据库的==约束条件==，反映**某一具体应用所涉及的数据必须满足的语义要求**

- 对属性的约束
- 对元组的约束

#### 5.3.1 属性上的约束条件

**定义方式**

- 列值非空 —— `NOT NULL`
- 列值唯一 —— `UNIQUE`
- 检查列值是否满足某个条件 —— `CHECK`
  - 定义视图时用到了`WITH CHECK OPTION`
  - 当做 省略掉where的where子句来用（create table时），放在约束的**列后**

==联想==：**unique + not null(用户定义的完整性) <=> primary key(实体完整性)** 

```mysql
-- 约束：（grade）列值非空
CREATE TABLE SC
(
	Sno CHAR(9),
	Cno CHAR(4),
	Grade SMALLINT NOT NULL,
	PRIMARY KEY(Sno,Cno)//定义了实体完整性，隐含了不允许取空值，在列级中可不写
);

```

```mysql
-- 约束：（Dname）列值唯一
CREATE TABLE DEPT
(
	Deptno NUMERIC(2),
	Dname CHAR(9) UNIQUE NOT NULL, //唯一且不能取空值
	Location CHAR(10),
	PRIMARY KEY(Depto)
);
```

```mysql
-- 约束：满足指定条件（Ssex只能取“男”或“女”）
CREATE TABLE Student
(
	Sno CHAR(9) PRIMARY KEY,
	Sname CHAR(8) NOT NULL,
	Ssex CHAR(2) CHECK(Ssex IN ('男','女')),
	Sage SMALLINT,
	Sdept CHAR(20)
);
```



#### 5.3.2 元组上的约束条件

 同属性值限制相比，元组级的限制可以设置**不同属性之间**的取值的相互约束条件



**定义方式：**

- 在`CREATE TABLE` 中使用 `CHECK` 短语定义**元组**上的约束条件（**放在create语句末尾**）

```mysql
-- 规定插入男性时，其名字不能以Ms.开头
CREATE TABLE Student
(
	Sno Char(9),
	Sname CHAR(8) NOT NULL,
	Ssex CHAR(2),
	Sage SMALLINT,
	Sdept CHAR(20),
	PRIMARY KEY(Sno),

	CHECK(Ssex='女' OR Sname NOT LIKE 'Ms.%')

);
```



----

### 5.4 完整性约束命名子句

SQL在`CREATE TABLE` 上提供了完整性约束命名子句 `CONSTAINT` ，用来**对完整性约束条件命名**，以便灵活地增加、删除一个完整性约束

#### **如何定义**

```mysql
CONSTRAINT <完整性约束条件名> <完整性约束条件>
```

完整性约束条件包括：

- **NOT NULL**
- **UNIQUE**
- **PRIMARY KEY**
- **FOREIGN KEY**
- **CHECK短语**



**举例**

```例子1
建立学生登记表Student，要求学号在90000~99999之间，姓名不能取空值，年龄小于30，性别只能是“男”或“女”
```

```mysql
-- 在Student表上建立了StudentKey、C1、C2、C3、C4这5个约束条件
CREATE TABLE Student
(
	Sno NUMERIC(6) CONSTRAINT C1 CHECK(Sno BETWEEN 90000 AND 99999),
	Sname CHAR(20) CONSTRAINT C2 NOT NULL,
	Sage NUMERIC(3) CONSTRAINT C3 CHECK(Sage < 30),
	Ssex CHAR (2) CONSTRAINT C4 CHECK(Ssex IN ('男','女')),
	CONSTRAINT StudentKey PRIMARY KEY(Sno)
);

```



```mysql
建立教师表Teacher,要求每个教师的应发工资不低于3000元。应发工资是工资列Sal与扣除项Deduct之和
```

```mysql
-- 在Teacher表上建立了TeacherKey、C1这2个约束条件
CREATE TABLE Teahcer
(
	Tno NUMERIC(4) PRIMARY KEY,
	TName CHAR(10),
	TSal NUMERIC(7,2),
	TDeduct NUMERIC(7,2),
	TDeptno NUMERIC(2),
	
	CONSTRAINT TeacherKey FOREIGN KEY(Tdeptno) REFERENCES DEPT(TDeptno),
	CONSTRAINT C1 CHECK(TSal+TDeduct >= 3000)
);
```



### 修改表中的完整性限制

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231101144149716.png" alt="image-20231101144149716" style="zoom:60%;" />

**修改约束**的策略：先删除，再add一个新约束

```mysql
-- 修改Student表中的约束条件，要求学号改为在0~100之间，年龄由小于30改为小于40
ALTER TABLE Student DROP CONSTRAINT C1;
ALTER TABLE Student ADD CONSTRAINT C1 CHECK(Sno BETWEEN 0 AND 100);
ALTER TABLE Student DROP CONSTRAINT C3;
ALTER TABLE Student ADD CONSTRAINT C3 CHECK(Sage < 40);
```



----



### 5.5 断言

SQL中可以使用 `CREATE ASSERTION` 语句，通过**声明式断言**来指定更具一般性的约束

#### 创建格式

每个断言都被赋予一个名字，check子句中的约束条件类似where子句的条件表达式

```mysql
CREATE ASSERTION <断言名> <check 子句>
DROP ASSERTION <断言名>
```


```mysql
-- 限制数据库课程最多60名学生选修
CREATE ASSERTION RESTRICT_DB_NUM
	CHECK
	(
        60 >=
        (
            SELECT COUNT(*)
            FROM COURSE,SC
            WHERE SC.CNO = COURSE.CNO AND CNAME = "数据库"
        )
    );
```

```mysql
-- 限制每一门课程最多60名学生选修'
CREATE ASSERTION RESTRICT_NUM
	CHECK
	(
        60 >=
        (
            SELECT COUNT(*) AS "选课人数"
            FROM SC
            GROUP BY CNO
        )
    );
```



----



### ==5.6 触发器==

**目的/作用** ：在某事件发生时 自动执行某些语句 （==事务-条件-动作规则==）

```
当特定的系统事件(如对一个表的增、删、改操作，事务的结束等)发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作。
```



e.g:

```\
每当增加一个学生信息到数据库表中时，都要检查其学号的位数是否正确，系别号是否大写;
每当订购一个商品时，都要从库存中减去订购的数量;
无论何时删除一行，都在某个存档表中保留一个副本;
```

触发器**响应**的事件（就三种语句）：

- **delete**
- **insert**
- **update**

**创建触发器**

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231031230828870.png" alt="image-20231031230828870" style="zoom:50%;" align = "left"/>

**相关说明：**

- 只有表的建立者才可以在表上创建触发器
- 触发器只能定义在 **实表**上（基本表），不能定义在临时表和视图上
- 触发器响应的事件（或者称为**触发事件**）：**delete, insert, update** 
- 触发器按照**所触发动作的间隔尺寸**可以分为**行级触发器**（`FOR EACH ROW`）和**语句级触发器**（`FOR EACH STATEMENT`）；语句级会执行一次，行级执行的次数以表的具体行数而定

`触发器名 必须在每个表中唯一`
`只有表才支持触发器，视图和临时表都不支持`
`触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器（因此每个表最多支持6个触发器）`

<img src="D:\My Files\笔记\数据库\数据库.assets\03ed9d4da89b684fd5fad5a3bfa7d3b.jpg" alt="03ed9d4da89b684fd5fad5a3bfa7d3b" style="zoom:80%;" />

**删除触发器**

注：**触发器不能更新或者覆盖**，为了修改一个触发器，必须先删除它，然后再重新创建

```mysql
DROP TRIGGER <触发器名>
```



使用触发器

delete触发器

------
------

# 数据库设计与应用开发篇


## 第六章 关系数据理论

这一章都是针对**关系模式**，即数据库的“结构”而言的，如表中的属性、函数依赖，但对于表内的“元组”操作，则不予讨论

**重点：**
几种“依赖”的概念      [[#什么是数据依赖？]]
规范化-范式               [[[#范式]]]( )
模式分解的几种算法  [[#6.4.3 分解算法]]

### 6.1为什么要引入关系数据理论？

#### 关系模式概念回顾

关系模式是关系的描述（**型**）

一个关系模式应当是五 元组   **```R(U,D,DOM,F)```**

>- R：关系的元组语义
>- U：表示关系中的所有属性
>- D：表示属性组U中的属性所来自的域
>- DOM：属性到域的映射
>- **F：属性组U上的一组数据依赖**

简化——**```R(U,F)```**



#### 什么是数据依赖？

定义：数据依赖是一个关系内部 ```属性与属性``` 之间的一种**约束**关系（[[#2.3关系完整性]]的表现形式）..............信息世界.联系

**种类：函数依赖，多值依赖**

##### ——函数依赖举例——

**解释：**==属性组X “决定” 属性组Y==（<span style="background:#d3f8b6">类似函数中自变量与函数值，已知x，就能求出 唯一的 f(x)的值</span>）
t(X)=s(X)=>t(Y)=s(Y)

比如描述一个学生的关系，可以有学号(`Sno`)、姓名(`Sname`)、 系名(`Sdept`) 等几个属性。
由于一个学号只对应一个学生，一个学生只在一个系学习。
因而当“学号”值确定之后，学生的姓名及所在系的值也就被唯一地确定了。记作**`Sno→Sname`, `Sno-> Sdept`**



##### ——相关术语及概念——

###### 平凡函数依赖与非平凡函数依赖

- **非平凡函数依赖**：如果X确定Y，但Y并不是X的**子集**，那么则称X是Y的非平凡函数依赖
- **平凡函数依赖**：如果X确定Y，Y是X的子集，那么则称X是Y的平凡函数依赖

一般研究的函数依赖都属于 `非平凡函数依赖`

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028171017284.png" alt="image-20231028171017284" style="zoom:33%;" align = "left"/>



###### 决定因素（BCNF）

若X->Y，则称 X 为这个函数依赖的决定属性组，也称为**决定因素**（不等同于码）



###### **完全函数依赖与部分函数依赖：**

- **完全函数依赖**：要想X是Y完全函数依赖，那么X中任何一个分量都不能丢，哪怕少一个，X都无法确定Y
- **部分函数依赖**：X是Y的部分函数依赖，则表明即便去掉X中的一个或多个分量，剩余分量也能确定Y

如：学号->所有属性，（学号，姓名）->所有属性，前者属于完全依赖，后者属于部分依赖（可去掉“姓名”）



###### 传递函数依赖

**传递函数依赖：** 如果X是Y的非平凡函数依赖，且Y不是X的函数依赖，同时Y是Z的非平凡函数依赖，则称Z对X传递函数依赖，记作

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028170212742.png" alt="image-20231028170212742" style="zoom:33%;" align = "left"/>

- 注意，**如果Y是X的函数依赖（X<->Y），则称Z直接依赖于X**

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028170925755.png" alt="image-20231028170925755" style="zoom: 33%;" align = "left"/>



###### 码（见2.1）



##### ——多值依赖——（有点难理解）

==别看我，看书去==（\~'^'~）P-178



#### 不遵循关系数据理论导致的问题

【例】建立一个描述学校教务的数据库，该数据库涉及的对象包括学生的学号(Sno)、所在系(Sdept)、 系主任姓名(Mname)、课程号(Cname)和成绩(Grade)。假设用一个单一的关系模式Student来表示，则该关系模式的属性集合为

**`U = ( Sno , Sdept , Mname , Cname , Grade ) `**

根据现实世界我们所熟知的，会有以下事实

- 一个系有若干学生，但一个学生只属于一个系
- 一个系只有一名(正职)负责人
- 一个学生可以选修多门课程，每门课程有若干学生选修
- 每个学生学习每一门课程有一个成绩

  ——这样的**语义限制，将会导致属性上的函数依赖**

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028171932701.png" alt="image-20231028171932701" style="zoom:50%;" align = "left"/>

记作：

`F = ( Sno −> Sdept , Sdept −> Mname , (Sno,Cno) −> Grade )` 

**下表是关系模式`Student`某一时刻的一个实例**

<img src="D:\My Files\笔记\笔记图片\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16-1694576184893-3.png" alt="在这里插入图片描述" style="zoom:50%;" />

我们说，这样的关系模式是失败的，因为它存在以下问题

- **数据冗余**：比如，每一个系的系主任姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同，这将浪费大量的存储空间
- **更新异常**：比如，某系更换系主任后，必须修改与该系学生有关的每一个元组
- **插入异常**：如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库
- **删除异常**：如果某个系的学生全部毕业了，则在删除该系学生信息的同时，这个系及其系主任的信息也丢掉了

**一个模式的数据依赖会有哪些不好的性质，如何改造一个不好的模式**——==规范化==

-----

### 6.2规范化

- ==**一个好的模式应该当不会发生插入异常、删除异常、更新异常、数据冗余应尽可能少**==



完全依赖-候选码-主属性

#### 范式

基本概念：[非主属性]()，[依赖](什么是数据依赖？)，[码]()

**高阶的范式满足低阶的定义**（如2NF：表中的每一个分量（属性）都是原子项且每一个<u>非主属性</u>**完全依赖**于任何一个候选码），为了方便，下面只列出`每个范式新增的要求`

- 1NF：表中的每一个分量（属性）**都是原子项**，即不能是嵌套表
- 2NF：每一个<u>非主属性</u>**完全依赖**于任何一个候选码（消除部分依赖）
- 3NF：关系模式中**不存在**非主属性对主属性的**传递依赖**（消除传递依赖）

- BCNF：所有决定因素都包含**码**

- 4NF：首先是1NF，其次所有**多值依赖**都是函数依赖


### 6.3  数据依赖的公理系统
<img src="D:\My Files\笔记\数据库\数据库.assets\3baefbc560032c68926aebc415349cc.jpg" alt="3baefbc560032c68926aebc415349cc" style="zoom:80%;" />
<img src="D:\My Files\笔记\数据库\数据库.assets\97481be5e4adc5ae62287bf2babf69b.jpg" alt="97481be5e4adc5ae62287bf2babf69b" style="zoom:80%;" />
<img src="D:\My Files\笔记\数据库\数据库.assets\fc7015420da9ad13ddcd2d2353a9efb.jpg" alt="fc7015420da9ad13ddcd2d2353a9efb" style="zoom:80%;" />



-----


### 6.4 模式分解

#### 6.4.1基本概念

1. 模式分解的目的：将低一级的关系模式分解为若干个高一级的关系模式（分解方式不唯一），实现规范化
2. **关系模式R<U, F>的一个关系分解**：ρ = {R<sub>1</sub><U<sub>1</sub>, F<sub>1</sub>>, R<sub>2</sub><U<sub>2</sub>, F<sub>2</sub>>,......,R<sub>n</sub><U<sub>n</sub>, F<sub>n</sub>>}，其中：
    <img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028172039591.png" alt="image-20231028172039591" style="zoom:60%;" align = "left"/>





<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028172119128.png" alt="image-20231028172119128" style="zoom:60%;" align = "left"/>

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028172142532.png" alt="image-20231028172142532" style="zoom:30%;" />
<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028172208198.png" alt="image-20231028172208198" style="zoom:33%;" />

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028172231054.png" alt="image-20231028172231054" style="zoom:43%;" align= "left"/>

4. 将SL分解为下面的两个关系模式：
	SD(SNO,Sdept)
	DL(Sdept, Sloc)
#### 6.4.2 模式分解的要求

单纯的‘’分解‘’并不能满足“规范化”的要求，需要加以限定：**至少保证分解有意义，不能丢失信息**（==1. 针对分解后的未经过操作的，2. 针对增删改查操作的）==

- **无损连接性**
- **保持函数依赖**

##### 1.无损连接性
###### 定义

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028172420173.png" alt="image-20231028172420173" style="zoom:80%;" align = "left"/>

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028172513946.png" alt="image-20231028172513946" style="zoom:70%;" align = "left"/>

<span style="background:#affad1">即所有子模式的笛卡尔积m<sub>ρ</sub>(r)为原模式（记录条数可以多不能少)</span>

- 两个关系中有相同的属性列，按等值连接处理
- 两个关系中没有相同的属性列，按自然连接处理

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028172614162.png" alt="image-20231028172614162" style="zoom:70%;" align = "left"/>



###### ==判别一个分解的无损连接性==

对于关系模式R<U, F>的一个关系分解: ρ = {R<sub>1</sub><U<sub>1</sub>, F<sub>1</sub>>, R<sub>2</sub><U<sub>2</sub>, F<sub>2</sub>>,......,R<sub>k</sub><U<sub>k</sub>, F<sub>k</sub>>}, 其中F = {A<sub>1</sub>, A<sub>2</sub>,.......,A<sub>n</sub>}

>1. 建立一个k行n列的表。（k个关系模式，n个属性）,
>
>2. 若<span style="background:#b1ffff">属性A<sub>j</sub></span>在<span style="background:#b1ffff">关系模式R<sub>i</sub></span>中，在对应的**i行j列**的位置填入<span style="background:#affad1">a<sub>j</sub></span>，若不在，则填入<span style="background:#affad1">b<sub>i, j</sub> </span>
>  a<sub>j</sub>：第j个属性包含在该行的关系模式中
>     b<sub>i, j</sub>：第j个属性不包含在第i个关系模式中
>
>3. 对每个函数依赖做下列操作：
>
>  > 基于FD<sub>i</sub>(X<sub>i</sub> -> A<sub>li</sub>)，**找到Xi所对应的列（属性组Xi中的各种属性）中具有相同符号那些行**，若其中有a<sub>li</sub> ，则全部改成a<sub>li</sub> ；否则全部行号最小的bi,j 。若某个b<sub>i,j</sub>被更改，那么该表中其它相同b<sub>i,j</sub>均做相同的更改。
>  > b改为a: 
>  > 	假设关系模式R1有A1,没有A2；R2没有A1，有A2；R3既有A1也有A2。
>  > 	但是<span style="background:rgba(74, 82, 199, 0.2)">存在函数依赖A1->A2, 那么可以认为只要是有A1的关系模式，都间接包含A2</span>，
>  > 	即R1,包含A2，R2、R3本来就包含A2
>  > 	      |A1 |A2 |
>  > 	|R1| a1   b12
>  > 	|R2| b21 a2
>  > 	|R3| a1   a2
>  > 	<span style="background:rgba(140, 140, 140, 0.12)">	有：A1->A2:</span>
>  > 		 |A1 |A2 |
>  > 	|R1| a1   <font color="#c0504d">a2</font>
>  > 	|R2| b21 a2
>  > 	|R3| a1   a2
>
>
>3. 比较扫描后有无变化，无变化则终止。**若表中有全a行，则分解具有无损连接性。**

<span style="background:#affad1">针对“一分二”，判断无损连接性：</span>
<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028172806421.png" alt="image-20231028172806421" style="zoom:80%;" align = "left"/>











----

###### **例题**

* <span style="background:rgba(240, 167, 216, 0.55)">一般法判定无损连接性：</span>
 <img src="D:\My Files\笔记\数据库\数据库.assets\454d53eb9beabde9a723b1f32d7c5ab.jpg" alt="454d53eb9beabde9a723b1f32d7c5ab" style="zoom:80%;" />

* <span style="background:rgba(240, 167, 216, 0.55)">针对“一分二”判断无损连接性</span>
<img src="D:\My Files\笔记\数据库\数据库.assets\595f2903c7914195fa5221097bcd017.jpg" alt="595f2903c7914195fa5221097bcd017" style="zoom: 20%;" />

##### 2.保持函数依赖
<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028172906453.png" alt="image-20231028172906453" style="zoom:70%;" align = "left"/>



----



#### 6.4.3 分解算法

几个重要事实：
- 若要求分解保持函数依赖，那么模式分解**总可以达到3NF**，不一定能达到BCNF
- 若要求分解既保持函数依赖，又具有无损连接性，可以达到3NF，不一定能达到BCNF
- 若要求分解具有无损连接性，那一定能够达到4NF（删掉非平凡的多值依赖）
##### 0.[[#判别一个分解的无损连接性]]
##### 1.转换为3NF的保持函数依赖的分解
- 1. 处理得到R<U, F>的<span style="background:rgba(5, 117, 197, 0.2)">F<sub>m</sub></span>
- 2. 找出<span style="background:rgba(92, 92, 92, 0.2)">不在F中出现的属性</span>（记为U<sub>0</sub>）,把这样的属性构成一个关系模式R<sub>0</sub><U<sub>0</sub>, F<sub>0</sub>>，把这些属性**从R中去掉**，剩余的属性仍记为U（U = U - U<sub>0</sub>）
- 3. 若有X->A ∈ F，并且X∪A=U，则ρ = {R}，算法终止（无法再分）
- 4. 否则，对F<span style="background:#affad1">按具有相同左部的原则分组</span>（假定分为K组），<span style="background:rgba(92, 92, 92, 0.2)">每一组函数依赖所涉及的全部属性</span>形成一个属性集U<sub>i</sub>，若U<sub>i</sub>包含于U<sub>j</sub>（i≠j）就去掉U<sub>i</sub>，于是
	ρ = {R<sub>1</sub><U<sub>1</sub>, F<sub>1</sub>>, R<sub>2</sub><U<sub>2</sub>, F<sub>2</sub>>,......,R<sub>k</sub><U<sub>k</sub>, F<sub>k</sub>>}∪R<sub>0</sub><U<sub>0</sub>, F<sub>0</sub>>构成R<U, F>的一个保持函数依赖的分解，并且每个R<sub>i</sub><U<sub>i</sub>, F<sub>i</sub>>均属于3NF
	==注：<span style="background:rgba(92, 92, 92, 0.2)">不在F中出现的属性</span>（记为U<sub>0</sub>）,把这样的属性构成一个关系模式R<sub>0</sub><U<sub>0</sub>, F<sub>0</sub>>==

**例题：**

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028173144611.png" alt="image-20231028173144611" style="zoom:70%;" align = "left"/>






##### 2.转换为3NF的既有无损连接性又保持函数依赖的分解(依赖于1.)
<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028173318231.png" alt="image-20231028173318231" style="zoom:70%;" align = "left"/>

==注：R<sup>*</sup><X, F<sub>X</sub>>表示由 码 和 码的依赖 组成的关系==，同样的，分解得到的关系的属性组不能有包含'关系'->(2)

**例题：**
<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028173436135.png" alt="image-20231028173436135" style="zoom:70%;" align = "left"/>















##### 3.转换为BCNF的无损连接分解

   思想：分解ρ中不属于BCNF的模式（X->A, X不是码——分解：==一个由A,X组成，一个丢掉A==）
   <img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028174450225.png" alt="image-20231028174450225" style="zoom:80%;" />

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028173934477.png" alt="image-20231028173934477" style="zoom:80%;" align = "left"/>

##### 4.达到4NF的具有无损连接性的分解
定理6.6和引理6.5见上图
<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028174507257.png" alt="image-20231028174507257" style="zoom:80%;" />

#### 6.4.4包含函数依赖和多值依赖的有效且完备的公理系统
<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028173521133.png" alt="image-20231028173521133" style="zoom:87%;" align = "left"/>

------

## <span style="background:#ff4d4f">第七章 数据库设计（待完成）</span>



### 7.1 数据库设计概述

大致的步骤：

需求分析 - 概念结构设计 - **逻辑结构**设计 - 物理结构设计 -  数据库实施 - 数据库运行和维护

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231020171033967.png" alt="image-20231020171033967" style="zoom:45%;" align = "left"/>

### 7.2 需求分析

#### 数据字典

### 7.3 概念结构设计

#### E-R模型

矩形——实体

椭圆形——属性

菱形——联系

#### 概念模型设计

##### 实体与属性的划分原则

怎么选属性？

##### E-R图的集成

1. 初步合并，消除冲突
2. 消除冗余，设计基本E-R图



主要冲突：

- 属性冲突
- 命名冲突
- 结构冲突



### 7.4 逻辑结构设计

#### E-R图转关系模型
==实际：将实体型和实体型之间的联系转换为关系模式==

关键：如何确定转换后的 **属性** 和 **码** 

转换的一般原则：
>- **一个实体型** 转换为 **一个关系模式**
>- **1:1联系** 转换为 
>  - 一个独立的关系模式
>  - 与任意一端的关系模式合并
>
>- **1:n联系** 转换为
>  - 一个独立的关系模式
>  - 与n端的关系模式合并
>
>- **m:n联系** 转换为
>  - 一个关系模式
>
>  - 三个或三个以上的实体间的一个**多元联系** 可以转换为 **一个关系模式**
>
>- 具有**相同码**的关系模式可以**合并**
>



#### 数据模型的优化

使用规范化理论对数据模型进行优化
具体方法：

**两种分解方式**

- 水平分解（分解元组）
- 垂直分解（分解属性）



### 7.5 物理结构设计

#### 存取方法

==索引，聚簇==

##### 索引（查找）

###### B+树索引

###### HASH索引

##### 聚簇



#### 存取结构



### 7.6 数据库的实施和维护




------


## 第八章 数据库编程（略）

-----
-----

# 数据库系统篇



## 第九章 关系查询处理与查询优化

### 9.1 关系数据库系统的查询处理

#### 查询处理步骤

四个步骤：==查询分析，查询检查，查询优化，查询执行==

- 分析**语法** -- 分析**语义** -- 转换为等价的**关系代数表达式** -- 进行**代数优化**和**物理优化** -- **执行**查询操作

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104165259828.png" alt="image-20231104165259828" style="zoom:50%;" align = "left"/>

```
（1）查询分析
任务：对查询语句进行扫描，分析词法、语法是否符合SQL语法规则
如果没有语法错误转入下一步
如果有语法错误则在报告中显示错误

（2）查询检查
对合法的查询语句进行语义检查，即根据数据字典中有关的模式定义检查语句中的数据库对象，如关系名、属性名是否存在和有效
如果是对视图的操作，则要用视图消解方法把对视图的操作转换成对基本表的操作
还要对权限、完整性约束进行检查，如果违反则拒绝查询
检查通过后，把SQL查询语句转化为内部表示，也即等价的关系代数表达式
在此过程中，要把数据库对象的外部名称换为内部表示
RDBMS一般用查询树（又称为语法分析树）来表示扩展的关系代数表达式

（3）查询优化
任务：每个查询都会有许多可供选择的执行策略和操作算法，查询优化就是选择一个高效执行的查询处理策略。按照优化的层次一般可以将查询优化分为 代数优化和查询优化

代数优化：是指关系代数表达式的优化，也即按照一定规则，通过对关系代数表达式进行等价变换，改变代数表达式中操作的次序和组合，使查询更高效
物理优化：是指存取路径和底层操作算法的选择。选择依据可以是基于规则的(rule based)、基于代价的(cost based)、基于语义的(semantic based)

（4）查询执行
依据优化器得到的执行策略生成查询执行计划，由 代码生成器(code generator) 生成执行这个查询计划的代码，然后加以执行，回送查询结果。
```



#### 选择操作和连接操作的算法实现（P-277）

##### 1.选择操作的实现

- 简单的全表扫描算法
- 索引扫描算法

##### 2.连接操作的实现

- 嵌套循环算法
- 排序—合并算法
- 索引连接算法
- hash join 算法



---

### 9.2 关系数据库系统的查询优化

查询优化的优点不仅在于用户不必考虑如何最好地表达查询以获得较高的效率，而且在于==系统可以比用户程序的“优化”做得更好==

**查询代价：优化方案的代价越小越好**

**集中式数据库**

`总代价 = I/O 代价 + CPU代价 + 内存代价 `

**分布式数据库**

`总代价 = I/O 代价 + CPU代价 + 内存代价 + 通信代价`

计算查询代价时一般用==查询处理读写的块数==作为衡量单位



#### 几个查询代价的计算实例

<img src="D:\My Files\笔记\数据库\数据库.assets\77be36a68a05d616bb8bd42da613cb5.jpg" alt="77be36a68a05d616bb8bd42da613cb5" style="zoom:150%;" />

<img src="D:\My Files\笔记\数据库\数据库.assets\4d01663976a531a39fb77d04380312f.jpg" alt="4d01663976a531a39fb77d04380312f" style="zoom:150%;" />

----



### 9.3 代数优化

==代数优化——即基于关系代数等价变换规则的优化方法==

#### 9.3.1 关系代数表达式等价变换规则

即：对关系代数表达式进行等价变换来提高查询效率

**常用的等价交换规则：**

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104162355508.png" alt="image-20231104162355508" style="zoom: 25%;" align = "left"/>



<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104162525684.png" alt="image-20231104162525684" style="zoom:25%;" align = "left"/>



<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104162545273.png" alt="image-20231104162545273" style="zoom:25%;" align = "left"/>



<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104162609824.png" alt="image-20231104162609824" style="zoom:25%;" align = "left"/>



<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104162630700.png" alt="image-20231104162630700" style="zoom:25%;" align = "left"/>



<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104162806480.png" alt="image-20231104162806480" style="zoom:25%;" align = "left"/>

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104162905572.png" alt="image-20231104162905572" style="zoom:25%;" align = "left"/>



<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104162931524.png" alt="image-20231104162931524" style="zoom: 25%;" align = "left"/>



<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104162956185.png" alt="image-20231104162956185" style="zoom:25%;" align = "left"/>



<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104163015225.png" alt="image-20231104163015225" style="zoom:25%;" align = "left"/>



#### 9.3.2 查询树的启发式优化

- **选择运算**应当尽可能**先做**
- 把投影操作和选择操作**同时进行**
- 把**投影**同其前或后的**双目运算**结合起来
- 把某些**选择**同在它前面要执行的**笛卡尔积**结合起来成为一个连接运算
- 找出**公共表达式**

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104164858165.png" alt="image-20231104164858165" style="zoom:80%;" />

```
总结来说，分为这几个部分：
将选择运算分解（分散了才能下沉）
将单目（针对一个关系的）选择、投影操作 下沉到叶子结点（查询树中叶子结点先做）
把选择和投影的串接合并成单个选择、单个投影或一个选择后跟一个投影
对于笛卡尔积——双目：对两个关系（做完选择、投影后）先连接，后执行选择（等值连接）
```

例：求选修了课程Ｃ2的学生姓名

 SELECT Student.Sname

 FROM  Student, SC

 WHERE Student.Sno=SC.Sno

 AND   SC.Cno='2';



<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104163603240.png" alt="image-20231104163603240" style="zoom:30%;" align = "left"/><img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104163723250.png" alt="image-20231104163723250" style="zoom:33%;" />



<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104163739702.png" alt="image-20231104163739702" style="zoom:50%;" align = "left"/>



<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104163827268.png" alt="image-20231104163827268" style="zoom:50%;" />

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104163851736.png" alt="image-20231104163851736" style="zoom:40%;" />



<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231104163926131.png" alt="image-20231104163926131" style="zoom:50%;" />



### 9.4 物理优化

- 基于规则的启发式优化
- 基于代价估算的优化
- 两者结合的优化方法



## 第十章 数据库恢复技术

[（数据库系统概论|王珊）第十章数据库恢复技术-第四、五、六、七节：数据库恢复技术和数据库镜像_解释什么是检查的恢复技术-CSDN博客](https://zhangxing-tech.blog.csdn.net/article/details/122764088)

### 事务的基本概念

- 事务是一系列的数据库操作，是数据库应用程序的基本逻辑单元
- 事务是 ==恢复==（C10） 和 ==并发控制==（C11） 的基本单位
- 事务是用户定义的一个<span style="background:rgba(92, 92, 92, 0.2)">数据库操作序列</span>，这些操作要么全做，要么全部做，是一个**不可分割**的工作单位
- 事务&程序：一个程序中包含多个事务

#### 定义事务的语句：

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028210337560.png" alt="image-20231028210337560" style="zoom:80%;" align = "left"/>

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028210410072.png" alt="image-20231028210410072" style="zoom:80%;" align = "left"/>

- **`BEGIN TRANSACTION`**：表示事务的**开始**
- **`COMMIT`**：表示事务的正常结束并**提交事务的所有操作**
- **`ROLLBACK`**：表示事务的结束，但没有正常结束，需要进行**回滚**（**撤销**已完成操作，使系统恢复至回滚前状态）

----

#### **事务的ACID特性：**



##### 1. 原子性（atom）

**含义：** 事务是数据库的 `逻辑工作单位` ，事务中包括的操作要么都做，要么都不做



##### 2. 一致性（consistency）

**含义：** 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态

- **一致性状态**：数据库只包含**成功事务**的提交结果 时的状态
- **不一致状态**：数据库中包含事务**未完成**时的状态



##### 3. 隔离性（isolate）

**含义：** 一个事务不能被其他事务干扰。

也即一个事务的内部操作及使用的数据对其他并发事务是隔离的，==并发执行==的各个事务之间不能互相干扰

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028210849832.png" alt="image-20231028210849832" style="zoom:50%;" />

##### 4. 持续性（duration）

**含义：** 一个事务一旦提交，它对数据库中数据的改变就是**永久性的**。接下来的其他操作或故障不应该对其执行结果有任何影响



#### **ACID特性被破坏——事务管理发生故障**

- 故障：没有执行完；虽然没有完，但是存储介质故障。破坏了ACID中的ACD
- 并发干扰：多个事务并行运行时，不同事务的操作交叉执行，互相干扰。破坏了ACID中的I

如：多个事务并行运行时，不同事务的操作交叉执行；事务在运行过程中被强行停止



### 故障的种类

- 事务故障
- 系统故障
- 介质故障
- 计算机病毒

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028213121028.png" alt="image-20231028213121028" style="zoom:70%;" align = "left"/>

**故障对数据库的影响：**

- **数据库本身**被破坏
- 数据库没有被破坏，但是事务的运行被非正常终止 可能导致 数据库中的**数据不正确**


#### 1. 事务内部的故障

**事务故障**： 某个**事务**在运行过程中由于种种原因<font color="#c0504d">未运行至正常终止点</font>就夭折了

- 大部分事务故障是<font color="#c0504d">非预期的</font>，是不能由应用程序处理的
- 事务故障——事务没有到达预期的终点（commit或是rollback）；因此需要<span style="background:rgba(92, 92, 92, 0.2)">撤销</span>该事务
- 如：运算溢出，输入数据有误，运算溢出，违反了某些完整性限制，某些应用程序出错，并行事务发生死锁

**恢复方法：撤销事务**

- 强行==回滚（ROLLBACK）==该事务

- 清除该事务对数据库的所有修改，使得这个事务象根本没有启动过一样



#### 2. 系统故障（软故障）

**系统故障：** 造成系统停转的任何事件，使得系统要重新启动

- 影响正在运行中的事务，但**不破坏**数据库
- **内存**中数据库缓冲区的信息全部丢失，**外部存储设备**上的数据未受影响
- 数据库中可能存放有 <font color="#c0504d">尚未完成</font>的事务的结果——造成数据库处于不正确的状态（类似于报告初稿还没改完，就把“成品”交上去了）
- 如：系统断电，DBMS代码错误，硬件错误（如CPU故障），操作系统故障



**恢复方法：undo/redo**

- **对于尚未完成的事务**：系统**重新启动**后，恢复程序要执行<font color="#c0504d">撤销（UNDO）</font>所有 <font color="#c0504d">未完成</font> 事务
- **对于已经完成的事务（未完全写回）**：系统**重新启动**后，恢复程序要执行 <font color="#c0504d">重做（REDO）</font>所有 <font color="#c0504d">已提交</font> 事务



#### 3. 介质故障（硬故障）

**介质故障**：指外存故障，会使存储在外存中的数据**部分丢失**或**全部丢失**。

- 如：磁盘损坏，磁头碰撞，瞬时强磁场干扰

**恢复方法：**

- **更换**或自动**切换磁介质**
- 装入**备份**
- **重做（REDO）**从此时起（备份）的成功事务，写入数据库



#### 4. 计算机病毒

计算机病毒本身不属于一种故障，但是它数据库的破坏会表现为前面的故障

-----



### 恢复的实现技术



<span style="background:rgba(240, 107, 5, 0.2)">恢复的基本原理：冗余</span>

- 建立冗余数据：**数据转储+登记日志文件**
- 利用这些冗余数据实施数据库恢复

#### 1. 数据转储

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028213728462.png" alt="image-20231028213728462" style="zoom:40%;" align = "left"/>

**类似网文里的的回溯大法（乐），但是从备份点到 “死亡点” 期间的 事务/状态 未保存**

当数据库遭到破坏时可以将（最近的）**后备副本装入**，但重装副本只能将数据库恢复到转储时的状态
要想恢复到故障发生时的状态，必须**重新运行**自转储以后的所有**更新事务**
注意这里有三个“时间点”：`备份数据库时的“转储点”`  `发生故障时的“故障点”`  `装入备份时的“备份点”`

<img src="D:\My Files\笔记\数据库\数据库.assets\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img" style="zoom:50%;" />

><img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028214827793.png" alt="image-20231028214827793" style="zoom:67%;" />





##### **数据转储分类：**

按状态：动态转储，静态转储
按范围：海量转储，增量转储

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028213538489.png" alt="image-20231028213538489" style="zoom:50%;" align = "left"/>

###### **1. 按照系统是否运行事务时分类**

**静态转储**

>是在系统中**无运行事务时**进行的转储操作(或者说：转储期间不允许任何更新事务运行)。
>即转储操作开始的时刻数据库处于一致性状态，而转储期间不允许(或不存在)对数据库的任何存取、修改活动。显然，静态转储得到的一定是一个**数据一致性**的副本
>
>**优点**：实现简单
>**缺点**：转储时必须等待正在运行的用户事物结束才能进行。降低了数据库的可用性


动态转储：

> 是指转储期间允许对数据库进行存取或修改，也即**转储和用户事物可以并发执行**
>
> **优点**：不用等待正在运行的事物，增强了数据库的可用性
> **缺点**：转储结束时后援副本上的数据库并不能**保证正确有效**
>
> 因此，==对于动态转储，还需要建立日志文件（log file）==。这样后备副本加上日志文件就能把数据库恢复到某一时刻的正确状态了



###### 2. 按转储的范围分类

>**海量转储**：每次转储**全部**数据库
>
>**增量转储**：每次只转储上一次转储后**更新过的数据**



#### 2. 登记日志文件

`是什么，是干什么的，具体怎么体现功能`

**日志文件：是用来记录事物对数据库更新操作的文件。主要有两种格式**

- 以**记录**为单位的日志文件（更新操作）
- 以**数据块**为单位的日志文件（更新前后的数据）



##### **登记的内容**

1. **以记录为单位**：各个事务的开始，结束标记，各个事务的所有更新操作

每个事物的开始、结束标记和每个更新操作均为一个日志记录，其内容主要包括

>1.**哪个事务，对谁做了什么操作**
>
>事务标识 (标明是哪个事务)、
>操作的类型 (插入、删除或修改)
>操作对象 ( 记录内部标识)
>
>2.**操作前后的状态**
>
>更新前数据的旧值 (对插入操作而言，此项为空值)
>更新后数据的新值 (对删除操作而言，此项为空值)



2. 对于**以块为单位**的日志文件：日志记录的内容包括事务标识和被更新的数据块。

由于将更新前的整个块和更新后的整个块都放入日志文件中，操作类型和操作对象等信息就不必放入日志记录中了



##### **日志文件的作用：**

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028222015885.png" alt="image-20231028222015885" style="zoom:50%;" align = "left"/>

**具体作用是**：

- **事务故障**恢复和**系统故障**恢复必须用日志文件

- 在**动态转储方式**中**必须**建立日志文件，后备副本和日志文件结合起来才能有效地 恢复数据库

- 在静态转储方式中也可以建立日志文件，当数据库毁坏后可重新装入后备副本(进行**介质故障**的恢复)

- 把数据库恢复到转储结束时刻的正确状态，然后==利用日志文件把已完成的事务进行重做处理，对故障发生时尚未完成的事务进行撤销处理==。这样不必重新运行那些已完成的事务程序就可把数据库恢复到故障前某一时刻的正确状态

>**数据转储 + 登记日志文件**
>
><img src="D:\My Files\笔记\数据库\数据库.assets\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16-1698503175350-10.png" alt="img" style="zoom:80%;" align = 'left'/>



<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028222816854.png" alt="image-20231028222816854" style="zoom:50%;" />



##### 登记日志文件时的原则

为保证数据库是可恢复的，登记日志文件时必须遵循两条原则

1. 登记的次序严格按照并发事务**执行的时间次序**
2. 必须**先修改日志文件**，后写数据库





----



### 恢复策略

==恢复策略==：借助**数据转储技术**，能使数据库恢复到（最近一次）转储时的状态；同时通过“引用” **登记日志文件**，能够对 **更新事务** 执行**UNDO、REDO**操作，从而实现数据库的恢复



#### 1.事务故障的恢复

**==UNDO==**

```problem
事务故障：事务在运行至正常终点前被终止（注意注意：对象是事务）
```

```solution
处理方法：恢复子系统利用日志文件撤销（UNDO）此事务已对数据库进行的修改(是由系统自动完成的，对用户透明（看不到）)
```

##### 恢复步骤：

1.**反向扫描**日志文件，查找到该事务的更新操作

2.**反向扫描**日志文件直至该事务的开始标志，对该事务的更新操作执行**逆操作**

- 如：若记录中是删除操作，则执行插入操作；若记录中是修改操作，则用修改前的值代替修改后的值



#### 2.系统故障的恢复

**==UNDO + REDO==**

```problem
系统故障：未完成事务对数据库的更新已经写入到数据库；已提交事务对数据库的更新可能还停留在缓冲区没来得及写入数据库
```

```solution
处理方法：重做(REDO)已完成的事务，撤销(UNDO)故障发生时未完成的事务
```

##### 恢复步骤：

**1. 找+分类：**
**正向扫描**日志文件，找出故障发生前<span style="background:rgba(92, 92, 92, 0.2)">已经提交</span>的事务，和故障发生时<span style="background:rgba(92, 92, 92, 0.2)">尚未完成</span>的事务，分别加入到`重做（REDO）队列`和`撤销（UNDO）队列`中

**2. 执行：**
**反向扫描** 日志文件，对 `撤销队列` 中的各个事务的 更新操作 执行**逆操作**
**正向扫描 **日志文件，对`重做队列`中的各个事务 重新执行 日志文件登记的操作（将日志记录中`更新后的值`写入数据库”）



#### 3.介质故障恢复

**==REDO==**

	介质故障：磁盘上的物理数据和日志文件被破坏(相对最少见、最严重的故障)

```solution
处理方法：重装数据库，然后重做(REDO)已完成的事务
```

##### 恢复步骤：

1.**装入**最新的数据库后备副本，是数据库恢复到最近一次转储的一致性状态
2.装入相应的日志文件副本（转储结束时刻的日志文件副本），**重做**已完成的事务

-----






### 具有检查点的恢复技术

**引入：**利用日志文件来进行数据库恢复是，必须检查所有的日志记录，耗费大量的时间

> **搜索整个日志将耗费大量的时间**
> **重复执行REDO的事务 耗费时间**



**具有检查点的恢复技术：**

```solution
在日志文件中增加一种类型的记录：检查点记录
增加一个重新开始文件（记录 “检查点记录” 在日志文件中的地址）,类似于操作系统FCB中记录了在FAT的开始地址
恢复子系统在登录日志文件期间动态地维护日志
```

><img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028225307656.png" alt="image-20231028225307656" style="zoom:30%;" align = "left"/>



**==怎么建立：==**

#### 检查点记录的内容：

**检查点记录**包括：

```
建立检查点时刻所有正在执行的事务
这些事务最近一个日志记录的地址
```

**重新开始文件** ：用来记录各个检查点记录在日志文件中的<font color="#c0504d">地址</font>



#### 动态维护的方法：

==周期性地执行建立检查点，保存数据库状态的操作==

**具体步骤：**

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028230632732.png" alt="image-20231028230632732" style="zoom:80%;" align = "left"/>

**使用检查点方法可以改善恢复效率**：
当事务T在一个**检查点之前提交**，T 对数据库所做的修改一定都已写入数据库，写入时间是在这个检查点建立之前或在这个检查点建立之时。这样，在进行恢复处理时，**没有必要**对 事务T 执行重做操作。





==**建完怎么用：**==

#### 系统使用检查点方法进行恢复的步骤：

==根据处于检查点时，事务的不同状态采取不同的恢复策略：（提交，执行完成）==

对于事务：在**检查点**前是否已经提交；在**系统故障**前是否已经执行完成
```
事务什么时候执行完/提交 —- 恢复策略
< Tc —— 不用管  
Tc~Tf —— REDO
> Tf —— UNDO
```



<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231028231251349.png" alt="image-20231028231251349" style="zoom:45%;" />



----




### 数据库镜像
**目的**：预防**介质故障**（磁盘坏了）
**方法**：每当主数据库更新时，DBMS自动地把更新后的数据<span style="background:rgba(92, 92, 92, 0.2)">复制到另一个磁盘上</span>

- 在实际应用中，只对**关键数据和日志文件**进行镜像，而不是对整个数据库进行镜像

**额外功能：并发操作**（）

**缺点**：频繁地复制数据会降低系统运行效率

<img src="D:\My Files\笔记\数据库\数据库.assets\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16-1698506599580-13.png" alt="img" style="zoom:80%;" align = "left"/>





----



## <span style="background:#ff4d4f">第十一章 并发控制(待完成)</span>

### 11.1 基本概念

**多事务的执行方式**：
事务串行方式：每个时刻只有一个事务运行，占用所有资源
交叉并行方式：单处理机系统交叉轮流执行各个“并行”事务
同时并发方式：多个处理机可以同时处理多个事务 

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127132649605.png" alt="image-20231127132649605" style="zoom:27%;" align = "left"/>

并发操作带来的**数据不一致性**（主要是因为破坏了事务的隔离性）：

- **丢失修改** 
  - 两个事务读入同一数据并修改，其中一个**修改丢失**。
  - 解决：T2应该在T1的修改操作完成后在执行读操作
- **不可重复读**
  - 事务T1读取数据后，事务T2执行更新操作（==增删<幻影现象>，插入==），使T2**无法再现**上一次的读取结果。
- **读“脏”数据**
  - 事务1修改某一数据，并将其写回磁盘。事务2读取同一数据后，事务1由于某种原因被撤消，这时事务1已修改过的数据恢复原值，**事务2读到的数据就与数据库中的数据不一致**，是不正确的数据

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127132316889.png" alt="image-20231127132316889" style="zoom:45%;" align = "left"/><img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127132352726.png" alt="image-20231127132352726" style="zoom:45%;" /><img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127132412587.png" alt="image-20231127132412587" style="zoom:45%;" />



```
分析问题的起因：
某一事务未完成时，另一事务开始（对相同资源做读写操作）

解决问题的方法：
对资源的操作可以分为 读和写（改）
在某一事务即将对某一资源进行读或写时，禁止其他事务对该资源的读或写操作。

并发控制机制就是要使用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免数据的不一致性。
```

**并发控制的主要技术**：封锁，时间戳，乐观控制法，多版本并发控制

**并发事务正确调度的准则**：可串行性

---



### 11.2 封锁

**封锁**：事务T在对某个数据对象（例如表、记录等）操作之前，**先向系统发出请求，对其加锁。**

- 加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务**不能更新**此数据对象
- 封锁类型：**排它锁（写锁）**，**共享锁（写锁）**



#### 11.2.2 基本封锁类型

##### 1. 排它锁（写锁，X锁）

若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务**都不能**再对A加任何类型的锁，直到T释放A上的锁

**2. 共享锁（读锁，S锁）**

若事务T对数据对象A加上S锁，则其它事务**只能再对A加S锁**，而不能加X锁，直到T释放A上的S锁

##### 3. 锁的相容矩阵

T1对资源A加了S/X锁后（未释放），T2能否对资源A加上S/X锁

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127134622597.png" alt="image-20231127134622597" style="zoom:40%;" align = "left"/>



#### 11.2.3 封锁协议

加锁时需要约定一些规则（封锁协议）

- 何时申请X锁或S锁
- 持锁时间、何时释放(操作结束还是事务结束)

==常用的封锁协议：三级封锁协议==——在不同程度上解决了"丢失修改，不可重复读，读脏数据"的问题

- 什么操作要申请封锁，何时释放封锁
- 协议级别越高，一致性程度越高

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127140853681.png" alt="image-20231127140853681" style="zoom:40%;" />

##### 1. 一级封锁协议

含义：事务T在**修改**数据R之前必须先对其加**X锁**，直到**事务结束**才释放
**事务结束方式**：正常结束（COMMIT），非正常结束（ROLLBACK）

==注意：只有等到 “获得锁” 时，该事务对资源的锁才开始生效==

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127140128680.png" alt="image-20231127140128680" style="zoom:45%;" align = "left"/>

```
可防止丢失修改
不能保证可重复读和不读“脏”数据（读数据时不需要加锁）
```

##### 2. 二级封锁协议

含义：**1级封锁协议** + 事务T在**读取**数据R前必须先加**S锁**，**读完**后即可释放S锁

```
2级封锁协议:
可以防止丢失修改和读“脏”数据。
由于读完数据后即可释放S锁，所以它不能保证可重复读。
```

><img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127140440620.png" alt="image-20231127140440620" style="zoom:80%;" />





##### 3. 三级封锁协议

含义：**1级封锁协议** + 事务T在**读取**数据R之前必须先对其加**S锁**，直到**事务结束**才释放

```
3级封锁协议可防止丢失修改、读脏数据和不可重复读
```

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127140652893.png" alt="image-20231127140652893" style="zoom:35%;" /><img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127140736392.png" alt="image-20231127140736392" style="zoom:40%;"/>



#### 11.2.4 活锁与死锁

封锁的方法可能会引起**死锁**和**活锁**



##### 1. 活锁

活锁举例：T2可能永远等待，无法获得锁（类似饥饿）

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127143219545.png" alt="image-20231127143219545" style="zoom:50%;" />

避免活锁的方法：**先来先服务**

即当多个事务请求封锁同一数据对象时：

- 封锁子系统按**`请求封锁的先后次序`**对这些事务**  **

- 该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁。



##### 2. 死锁

数据库中产生死锁的原因：两个或者多个事务都已经封锁了一些数据对象，然后都请求对已被其他事务封锁的数据对象加锁，从而出现死等待——=="拿着一个东西不放，找另一个东西"==

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127145307488.png" alt="image-20231127145307488" style="zoom:25%;" />

两种解决方案：预防死锁的发生；允许发生死锁，当发生死锁时解除死锁

###### （1）预防死锁

就是要：破坏产生死锁的条件 

**一次封锁法**

>策略：要求每个事务必须**一次**将所有要使用的数据**全部加锁**（类似OS中的AND）
>缺点：降低了系统的并发度

**顺序封锁法**

>策略：规定一个**封锁顺序**，所有的事务都按照这个顺序实施封锁。
>
>缺点：维护封锁顺序的成本高；难以用 静态的顺序 约束 动态的请求



###### （2）死锁的诊断和解除

**超时法**

>诊断方式：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁
>
>问题：误判、未能及时发现死锁（时限过长）

**等待图法**

>表现出"谁等待谁"

**解除方法：**

> 选择一个处理**死锁代价最小**的事务，将其撤销，**释放**此事务持有的所有锁

----



### 11.3 并发调度的可串行性

**引入/回忆**：串行调度的结果不会出错，而并发事务调度可能有不同的结果——==哪种结果是正确的，怎么保证是正确的调度？==



#### 11.3.1 可串行化调度

规定：执行**结果等价**于串行调度的调度——**可串行化调度**（正确的调度方法）

- 几个事务的并行执行是正确的，当且仅当其结果与按某一次序串行地执行它们时的结果相同

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127153025661.png" alt="image-20231127153025661" style="zoom:65%;" /><img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127153051231.png" alt="image-20231127153051231" style="zoom:53%;" />

两种结果都是串行调度的结果，则得到其中一个结果的 调度方式是正确的，是可串行化调度；其他结果均是错误的，相应调度也称之为不可串行化调度

#### 11.3.2 冲突可串行化调度

如何判断调度是可串行化的调度：是冲突可串行化的调度 -> 是可串行化的调度

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127153552068.png" alt="image-20231127153552068" style="zoom:50%;" align = "left"/>

>不同事务的冲突操作 和 同一事务的两个操作时不能交换的
>
>- **不同事务**的冲突操作  不可交换
>- **同一事务内部**的两个操作  不可交换
>- 不同事务，**同一数据**的**读读**操作  可以交换
>- 不同事务，不同数据，无论读写  均可交换

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127154030818.png" alt="image-20231127154030818" style="zoom:47%;" align = "left"/>

即：SC---------->SC'(串行的)  <==> SC是冲突可串行化的 ==> SC是可串行化的调度
<img src="D:\My Files\笔记\数据库\数据库.assets\49643ee3e66f27700437af9de0eab14.jpg" alt="49643ee3e66f27700437af9de0eab14" style="zoom:33%;" />                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

---



### 11.4 两段锁（2PL）协议

**作用：**使用两段锁协议来实现并行调度的可串行性，从而保证调度的正确性

**两段锁**：所有事务必须分为**两个阶段**对数据项==加锁和解锁==

- 获得封锁（扩展阶段）：在对任何数据进行读、写操作之前，事务首先要**获得**对该数据的封锁（**即先进行P操作**）
- 释放阶段（收缩阶段）：==在释放一个封锁之后，事务不再获得任何其他封锁==
- 两个阶段都不能干别的（如扩展阶段不能释放封锁）

<img src="D:\My Files\笔记\数据库\数据库.assets\950885882a9866539aa26b532002e25.jpg" alt="950885882a9866539aa26b532002e25" style="zoom:15%;" align = "left"/>

- 事务遵循两段锁协议是可串行化调度的==充分条件==
- 两段锁协议 不等于 一次封锁法，**一次封锁法遵守两段锁协议**，但两段锁协议不要求事务必须一次将所有要使用的数据全部加锁
- 遵守两段锁协议的事务可能发生死锁

---



### 11.5 封锁的粒度

#### 11.5.1 封锁粒度

封锁对象的大小称为封锁粒度

- 封锁的对象:逻辑单元（属性值，索引值等），物理单元（页，物理记录等）
- 封锁的粒度越大，及数据库所能够封锁的**数据单元**就越小，**并发度**就越小，**系统开销**也越小

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127161524322.png" alt="image-20231127161524322" style="zoom:40%;" align = "left"/>

#### **11.5.2 多粒度封锁**

**多粒度封锁：** 在一个系统中同时支持多种封锁粒度供不同的事务选择

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127162140050.png" alt="image-20231127162140050" style="zoom:70%;" align = "left"/>

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127162215052.png" alt="image-20231127162215052" style="zoom:33%;" />

**多粒度封锁协议：**允许多粒度树中的每个结点被**独立地**加锁，对一个结点加锁意味着这个结点的**所有后裔结点**也会被加上**相同类型**的锁。因此，在多粒度封锁中一个数据对象可能存在如下两种封锁方式

- 显式封锁：直接加到数据库对象上的封锁
- 隐式封锁：由于上级结点加锁而使该数据对象也被加锁

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127162327221.png" alt="image-20231127162327221" style="zoom:50%;" align = "left"/>





#### **11.5.3 意向锁**

如果对一个节点加意向锁，则说明该节点的下层节点正在被加锁

- 对任一结点加锁时，必须**先**对它的**上层结点**加锁

三种常用的意向锁：意向共享锁（IS锁），意向排他锁（IX锁），共享意向排他锁（SIX锁）

<img src="D:\My Files\笔记\数据库\数据库.assets\image-20231127162426399.png" alt="image-20231127162426399" style="zoom:50%;" align = "left"/>